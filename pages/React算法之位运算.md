## 概念
	- 位运算直接处理每一个比特位(bit), 是非常底层的运算, [[#green]]==优势是速度快==, [[#red]]==劣势就是不直观且只支持整数运算.==
- ## 特性
	- |位运算|用法|描述|
	  |--|--|--|
	  |按位与(&)|a & b|对于每一个比特位,两个操作数都为 1 时, 结果为 1, 否则为 0|
	  |按位或(  )|a  b|对于每一个比特位,两个操作数都为 0 时, 结果为 0, 否则为 1|
	  |按位异或(^)|a ^ b|对于每一个比特位,两个操作数相同时, 结果为 0, 否则为 1|
	  |按位非(~)|~ a|反转操作数的比特位, 即 0 变成 1, 1 变成 0|
	  |左移(<<)|a << b|将 a 的二进制形式向左移 b (< 32) 比特位, 右边用 0 填充|
	  |有符号右移(>>)|a >> b|将 a 的二进制形式向右移 b (< 32) 比特位, 丢弃被移除的位, 左侧以最高位来填充|
	  |无符号右移(>>>)|a >>> b|将 a 的二进制形式向右移 b (< 32) 比特位, 丢弃被移除的位, 并用 0 在左侧填充|
	- [`ES5`规范中](https://www.ecma-international.org/ecma-262/5.1/#sec-11.10):
		- 位运算只能在[[#blue]]==整型==变量之间进行运算
		  logseq.order-list-type:: number
		- JavaScript 中的`Number`类型在底层都是以浮点数(参考 IEEE754 标准)进行存储.
		  logseq.order-list-type:: number
		- JavaScript 中所有的按位操作符的操作数都会被[转成补码（two's complement）](https://www.ecma-international.org/ecma-262/5.1/#sec-9.5)形式的`有符号32位整数`.
		  logseq.order-list-type:: number
	- 所以在 JavaScript 中使用位运算时, 有 2 种情况会造成[[#red]]==结果异常==：
		- 操作数为浮点型(虽然底层都是浮点型, 此处理解为显示性的浮点型)
		  logseq.order-list-type:: number
			- `转换流程: 浮点数 -> 整数(丢弃小数位) -> 位运算`
		- 操作数的大小超过`Int32`范围(`-2^31 ~ 2^31-1`). 超过范围的二进制位会被截断, 取`低位32bit`.
		  logseq.order-list-type:: number
			- ```
			  Before: 11100110111110100000000000000110000000000001
			  After:              10100000000000000110000000000001
			  ```
	- [[#green]]==隐式转换：==
		- `'str' >>> 0; *//  ===> Number('str') >>> 0  ===> NaN >>> 0 = 0*`
- ## 基本使用
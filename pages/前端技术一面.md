- ## HTML面试题
  collapsed:: true
	- {{cards [[html]]}}
	- HTML语义化标签？有哪些？ #card #html
	  collapsed:: true
		- 可读性
		- SEO
		- 标签：
			- header
			  footer
			  main
			  aside
			  article
			  section
			  address
			  summary/details
			  menu
			  h1/h2/h3/h4/h5/h6
			  img
			  p
			  strong/italic
- ## CSS面试题
	- {{cards [[css]]}}
	- offsetWidth = ？,box-sizing: border-box时，offsetWidth = ？ #card #css
	  collapsed:: true
		- $$offsetWidth = width + padding * 2 + border * 2$$
		- $$box-sizing: border-box时，offsetWidth = width$$
	- BFC? 应用？#card #css
	  collapsed:: true
		- Block Formatting Context，块级格式化上下文
		- ### 创建 BFC
		  background-color:: pink
			- 根元素或包含根元素的元素
			  logseq.order-list-type:: number
			- 浮动元素 float ＝ left | right 或 inherit**（≠ none）**
			  logseq.order-list-type:: number
			- 绝对定位元素 position ＝ absolute 或 fixed
			  logseq.order-list-type:: number
			- display ＝ inline-block | flex | inline-flex | table-cell 或 table-caption
			  logseq.order-list-type:: number
			- overflow ＝ hidden | auto 或 scroll** (≠ visible)**
			  logseq.order-list-type:: number
		- ### BFC 的特性
		  background-color:: pink
			- 1. BFC 是一个独立的容器，容器内子元素不会影响容器外的元素。反之亦如此。
			  2. 盒子从顶端开始垂直地一个接一个地排列，盒子之间垂直的间距是由 margin 决定的。
			  3. 在同一个 BFC 中，两个相邻的块级盒子的**垂直外边距**会发生重叠。
			  4. **BFC 区域不会和 float box 发生重叠。**
			  5. **BFC 能够识别并包含浮动元素，当计算其区域的高度时，浮动元素也可以参与计算了。**
		- ### BFC 的作用
		  background-color:: pink
			- #### 1. 包含浮动元素（清除浮动）
			  background-color:: green
				- 浮动元素会脱离文档流(绝对定位元素也会脱离文档流)，导致无法计算准确的高度，这种问题称为**高度塌陷**。
				  解决高度塌陷问题的前提是能够识别并包含浮动元素，也就是**清除浮动**。
				- [[#green]]==解决方法==：**在容器（container）中创建 BFC。**
				- ![image.png](../assets/image_1688987355784_0.png)
			- #### 2. 导致外边距折叠
			  background-color:: green
				- **相邻**的两个盒子（可能是兄弟关系也可能是祖先关系）的垂直边距相遇时， 它们将形成一个外边距。这个外边距的高度等于两个发生折叠的外边距的高度中的**较大者**。
			- #### 3. 避免外边距折叠
			  background-color:: green
				- **外边距折叠（Margin collapsing）只会发生在属于同一BFC的块级元素之间**。如果它们属于不同的 BFC，它们之间的外边距则不会折叠。所以通过**创建一个不同的 BFC** ，就可以避免外边距折叠。
	- 居中对齐实现？ #card #css
	  collapsed:: true
		- ### 水平居中
		  background-color:: pink
			- **inline元素**：`text-align: center`
			- **block元素**：`margin: auto`
			- **absolute元素**：`left: 50%; margin-left: 负值`
		- ### 垂直居中
		  background-color:: pink
			- **inline元素**：`line-height: height`
			- **absolute元素**：
				- `top: 50%; margin-top: 负值`
				- `left: 50%; top: 50%; transform: translate(-50%, -50%)`
				- `top, left, bottom, right: 0; margin: auto`
		- ### flexbox
		  background-color:: pink
			- `display: flex; align-items: center; justify-content: center;`
		- ### grid
		  background-color:: pink
			- ```
			  .container {
			    display: grid;
			    place-items: center;
			  }
			  
			  // or
			  .container {
			    display: grid;
			    place-content: center;
			  }
			  ```
	- line-height如何继承？ #card #css
	  collapsed:: true
		- 1. line-height为具体数值，如 `30px` 继承该数值；
		- 2. line-height为比例，如 `2`，继承该比例；
		- 3. line-height为百分比，如 `200%` ，[[#blue]]==继承计算后的数值==；
	- rem、em？ #card #css
	  collapsed:: true
		- `rem`: 根据根元素(即 `html`)的 `font-size`
		- `em`: 根据**自身元素**的 `font-size`
	- z-index 与 层叠上下文 #card #css
	  collapsed:: true
		- > https://segmentfault.com/a/1190000043788683
		- ### 问题
		  background-color:: pink
			- 为什么我设置的 **`z-index`** 值不生效呢？
		- ### 层叠上下文
		  background-color:: blue
		  collapsed:: true
			- ![image.png](../assets/image_1694100765066_0.png)
			- #### 利用 CSS 层叠上下文不让 浮动元素 覆盖 块元素
				- 正常情况下，**浮动元素** 和 **块级元素** 之间的表现如下：
					- ![image.png](../assets/image_1694100996183_0.png){:height 123, :width 340}
				- 让 **block 元素** 产生一个新的层叠上下文，例如将它的 **`opacity`** 属性值设置成任意 **小于 1** 的值即可，以下是设置了 `opacity: 0.9;` 的效果：
					- ![image.png](../assets/image_1694101068017_0.png){:height 134, :width 341}
		- ### 总结
		  background-color:: blue
			- 一个元素产生层叠上下文，那么它会比其他元素拥有高优先级
			- 一个层叠上下文中元素的排列顺序：
				- 1. 层叠上下文的 **背景色、背景图（如果有）、边框（如果有）**
				  2. **定位元素**，且 **`z-index < 0`**
				  3. **（非定位）块元素**
				  4. **（非定位）浮动元素**
				  5. **（非定位）行内（块）元素**
				  6. **定位元素**，且 **`z-index = auto | 0`**
				  7. **定位元素**，且 **`z-index > 0`**
			- 比较两个元素的层叠顺序，先确定它们 **所处的层叠上下文** 的层叠顺序：
				- 处于 **相同层叠上下文**，则按如上顺序计算
				  处于 **不同层叠上下文**，则比较它们各自层叠上下文的顺序
			- **层叠上下文** 和 **图层** 不是同一个东西，即使从视图表现来看是相似的，但本质不同
	- css 如何实现左侧固定300px，右侧自适应的布局 #card #css
	  collapsed:: true
		- ### flex 布局
		  background-color:: pink
			- ```
			  <div class="container">
			    <div class="left"></div>
			    <div class="main"></div>
			  </div>
			  ```
			- ```
			  .container {
			    display: flex;
			  }
			  
			  .left {
			    flex-basis: 300px;
			  }
			  
			  .main {
			    flex: 1 1;
			  }
			  
			  ```
		- ### grid 布局
		  background-color:: pink
			- ```
			  .container {
			    display: grid;
			    grid-template-columns: 300px 1fr;
			  }
			  ```
	- 如何实现三列均分布局 #card #css
	  collapsed:: true
		- ### 使用 flex 布局
		  background-color:: pink
			- ```
			  .flex-container {
			  	display: flex;
			      flex-wrap: wrap;
			  }
			  
			  .item {
			  	flex: 0 0 calc(100% / 3);
			      // flex: 1; 相当于flex-grow: 1; flex-shrink: 1; flex-basis: 0%;
			  }
			  ```
			- [[#red]]==缺点==：**不能够很好的为子元素设置左右间隙**
		- ### 使用 grid 布局
		  background-color:: pink
			- 使用 Grid 直接操作容器即可，[[#green]]==对于子元素之间的间隙也可以很好地控制。==
			- ```
			  .grid-container {
			  	display: grid;
			      grid-template-columns: 1fr 1fr 1fr;
			      gap: 1rem;
			  }
			  ```
	- CSS 如何实现固定长宽比的元素 #card #css
	  collapsed:: true
		- 现代化的解决方案是使用长宽比的 CSS 属性: `aspect-ratio: 1/1`
	- CSS 如何避免样式冲突 #card #css
	  collapsed:: true
		- ### 1. BEM 式
		  background-color:: pink
			- ```
			  .home-page {
			    .home-page-btn {
			    }
			  }
			  ```
			- [[#red]]==缺点：==有些太长，可适当简化，只包裹该页面组件的根类名，但有可能增加样式冲突的风险
		- ### 2. CSS Scoped
		  background-color:: pink
			- `scoped css` 会对当前组件(scope)下所有元素生成唯一的属性或类名，对所有 CSS 规则将携带唯一属性实现作用域的命名保护。
			- ```
			  // 手动写
			  .btn {
			  }
			   
			  // 编译后
			  .btn .jsx-1287234 {
			  }
			  ```
		- ### 3. CSS Module
		  background-color:: pink
			- `module css` 会对类名进行 hash 化
	- 有没有使用过 css variable，它解决了哪些问题 #card #css
	  collapsed:: true
		- css 变量减少样式重复定义，比如同一个颜色值要在多个地方重复使用，以前通过 less 和 sass 预处理做到，现在 css 变量也可以做到，方便维护，提高可读性
		- ```
		  :root{
		    --color: red;
		  }
		  p {
		    color: var(--color);
		  }
		  ```
		- 方便在 js 中使用：
		- ```
		  // 设置变量
		  document.getElementById("box").style.setPropertyValue('--color', 'pink')
		  // 读取变量
		  doucment.getElementById('box').style.getPropertyValue('--color').trim()    //pink
		  // 删除变量
		  document.getElementById('box').style.removeProperty('--color')
		  ```
	- 如何使用 CSS 实现网站的暗黑模式 (Dark Mode) #card #css
		- ### 1. [Dark mode in 5 minutes, with inverted lightness variables](https://lea.verou.me/2021/03/inverted-lightness-variables/)
			- > [prefers-color-scheme自由切换网站主题背景色变化](https://www.bilibili.com/read/cv18661145/)
			- ```
			  @media (prefers-color-scheme: dark) {
			    :root {
			    }
			  }
			  ```
		- 2. [如何实现网页 dark-model](https://dev.to/akhilarjun/one-line-dark-mode-using-css-24li)
			- ```
			  html[theme='dark-mode'] {
			    filter: invert(1) hue-rotate(180deg);
			    transition: color 300ms, background-color 300ms; /*过渡动画*/
			  }
			  ```
			- [[#green]]==JS 实现：==
				- ```
				  const html = document.getElementsByTagName('html')[0];
				  const toggleTheme = (theme) => {
				      html.dataset.theme = theme;
				  } // 在UI点击模式切换按钮时调用这个方法
				  ```
- ## JavaScript面试题
  collapsed:: true
	- [[JavaScript错题集]]
	- ### JavaScript手写题
	  background-color:: pink
		- 手写JS深拷贝-[[JavaScript专题之深浅拷贝]]
		- 手写Promise-[[手写Promise]]
		- 手写bind、call、apply- [[JavaScript深入之bind的模拟实现]]、 [[JavaScript深入之call和apply的模拟实现]]
		- 手写flatern  concat递归
		-
- ## DOM 面试题
	- 如何实现图片的懒加载 #card #css
		- [[#blue]]==1. 如何判断图片出现在了当前视口==
		  [[#blue]]==2. 如何控制图片的加载==
		- ### 方案一: 位置计算 + 滚动事件 (Scroll) + DataSet API
		  background-color:: pink
			- #### 1. 如何判断图片出现在了当前视口
				- `clientTop`，`offsetTop`，`clientHeight` 以及 `scrollTop`
				- **监听 `window.scroll` 事件**
			- #### 2. 如何控制图片的加载
				- `<img data-src="shanyue.jpg" />`
				- 首先设置一个临时 Data 属性 `data-src`，控制加载时使用 `src` 代替 `data-src`，可利用 DataSet API 实现。
				- `img.src = img.datset.src`
		- ### 方案二: getBoundingClientRect API + Scroll with Throttle + DataSet API
		  background-color:: pink
			-
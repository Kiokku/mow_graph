- > https://www.hello-algo.com/chapter_graph/graph_traversal/
-
- >**图与树的关系**
  > 
  >树代表的是“一对多”的关系，而图则具有更高的自由度，可以表示任意的“多对多”关系。因此，我们可以把树看作是图的一种特例。显然，**树的遍历操作也是图的遍历操作的一种特例**，建议你在学习本章节时融会贯通两者的概念与实现方法。
- ## 广度优先遍历 BFS
	- **广度优先遍历是一种由近及远的遍历方式，从距离最近的顶点开始访问，并一层层向外扩张**。具体来说，从某个顶点出发，先遍历该顶点的所有邻接顶点，然后遍历下一个顶点的所有邻接顶点，以此类推，直至所有顶点访问完毕。
	- ![image.png](../assets/image_1686885013715_0.png)
	- ### 算法实现
	  background-color:: pink
		- BFS 通常借助「队列」来实现。队列具有“先入先出”的性质，这与 BFS 的“由近及远”的思想异曲同工。
			- 1. 将遍历起始顶点 `startVet` 加入队列，并开启循环；
			  2. 在循环的每轮迭代中，弹出队首顶点并记录访问，然后将该顶点的所有邻接顶点加入到队列尾部；
			  3. 循环步骤 `2.` ，直到所有顶点被访问完成后结束；
		- [[#blue]]==为了防止重复遍历顶点，我们需要借助一个哈希表 `visited` 来记录哪些节点已被访问。==
		- ```
		  /* 广度优先遍历 BFS */
		  // 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点
		  function graphBFS(graph, startVet) {
		      // 顶点遍历序列
		      const res = [];
		      // 哈希表，用于记录已被访问过的顶点
		      const visited = new Set();
		      visited.add(startVet);
		      // 队列用于实现 BFS
		      const que = [startVet];
		      // 以顶点 vet 为起点，循环直至访问完所有顶点
		      while (que.length) {
		          const vet = que.shift(); // 队首顶点出队
		          res.push(vet); // 记录访问顶点
		          // 遍历该顶点的所有邻接顶点
		          for (const adjVet of graph.adjList.get(vet) ?? []) {
		              if (visited.has(adjVet)) {
		                  continue; // 跳过已被访问过的顶点
		              }
		              que.push(adjVet); // 只入队未访问的顶点
		              visited.add(adjVet); // 标记该顶点已被访问
		          }
		      }
		      // 返回顶点遍历序列
		      return res;
		  }
		  ```
	-
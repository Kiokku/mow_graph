- > https://github.com/mqyqingfeng/Blog/issues/155
-
- ## 前言
	- 0.1 + 0.2 是否等于 0.3 作为一道经典的面试题，已经广外熟知，说起原因，大家能回答出这是浮点数精度问题导致，也能辩证的看待这并非是 ECMAScript 这门语言的问题，今天就是具体看一下背后的原因。
- ## 数字类型
	- ECMAScript 中的 Number 类型使用 IEEE754 标准来表示整数和浮点数值。所谓 **IEEE754** 标准，全称 IEEE 二进制浮点数算术标准，这个标准定义了表示浮点数的格式等内容。
	- 在 IEEE754 中，规定了四种表示浮点数值的方式：单精确度（32位）、双精确度（64位）、延伸单精确度、与延伸双精确度。像 **ECMAScript 采用的就是双精确度**，也就是说，会用[[#blue]]==64 位来储存一个浮点数==。
- ## 浮点数转二进制
	- ```
	  0.1 = a * 2^-1 + b * 2^-2 + c * 2^-3 + d * 2^-4 + ...
	  
	  0 + 0.2 = a * 2^0 + b * 2^-1 + c * 2^-2 + ...   (a = 0)
	  0 + 0.4 = b * 2^0 + c * 2^-1 + d * 2^-2 + ...   (b = 0)
	  0 + 0.8 = c * 2^0 + d * 2^-1 + e * 2^-2 + ...   (c = 0)
	  1 + 0.6 = d * 2^0 + e * 2^-1 + f * 2^-2 + ...   (d = 1)
	  1 + 0.2 = e * 2^0 + f * 2^-1 + g * 2^-2 + ...   (e = 1)
	  0 + 0.4 = f * 2^0 + g * 2^-1 + h * 2^-2 + ...   (f = 0)
	  0 + 0.8 = g * 2^0 + h * 2^-1 + i * 2^-2 + ...   (g = 0)
	  1 + 0.6 = h * 2^0 + i * 2^-1 + j * 2^-2 + ...   (h = 1)
	  ....
	  ```
	- 然后你就会发现，这个计算在不停的循环，所以 0.1 用二进制表示就是 0.00011001100110011……
- ## 浮点数的存储
	- IEEE754 标准认为，一个浮点数 (Value) 可以这样表示：
	- > Value = sign * exponent * fraction
	- 简单理解就是科学计数法
	- 比如 -1020，用科学计数法表示就是:
	- > -1 * 10^3 * 1.02
	- 对于二进制也是一样，以 0.1 的二进制 0.00011001100110011…… 这个数来说：
	- > 1 * 2^-4 * 1.1001100110011……
	- 而当只做二进制科学计数法的表示时，这个 Value 的表示可以再具体一点变成：
	- > V = (-1)^S * (1 + Fraction) * 2^E
	- `(-1)^S` 表示符号位，当 S = 0，V 为正数；当 S = 1，V 为负数。
	- 再看 `(1 + Fraction)`，这是因为所有的浮点数都可以表示为 1.xxxx * 2^xxx 的形式，前面的一定是 1.xxx，那干脆我们就不存储这个 1 了，直接存后面的 xxxxx 好了，这也就是 Fraction 的部分。
	-
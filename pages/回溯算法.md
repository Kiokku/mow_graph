- > https://www.hello-algo.com/chapter_backtracking/backtracking_algorithm/
-
- **「回溯算法 Backtracking Algorithm」**是一种通过**穷举**来解决问题的方法，它的核心思想是从一个初始状态出发，暴力搜索所有可能的解决方案，当遇到正确的解则将其记录，直到找到解或者尝试了所有可能的选择都无法找到解为止。
- 回溯算法通常采用**「深度优先搜索 DFS」**来遍历解空间。在二叉树章节中，我们提到前序、中序和后序遍历都属于深度优先搜索。下面，我们将从前序遍历入手，逐步了解回溯算法的工作原理。
- > ❓ **例题一**
  >
  > 给定一个二叉树，搜索并记录所有值为 7 的节点，返回节点列表。
- **解题思路**：前序遍历这颗树，并判断当前节点的值是否为 7 ，若是则将该节点的值加入到结果列表 `res` 之中。
- ```
  /* 前序遍历：例题一 */
  function preOrder(root, res) {
      if (root === null) {
          return;
      }
      if (root.val === 7) {
          // 记录解
          res.push(root);
      }
      preOrder(root.left, res);
      preOrder(root.right, res);
  }
  ```
- ## 尝试与回退
	- **之所以称之为回溯算法，是因为该算法在搜索解空间时会采用“尝试”与“回退”的策略**。当算法在搜索过程中遇到某个状态无法继续前进或无法得到满足条件的解时，它会撤销上一步的选择，退回到之前的状态，并尝试其他可能的选择。
	- 值得说明的是，[[#red]]==**回退并不等价于函数返回**==。为解释这一点，我们对例题一稍作拓展。
	- > ❔ **例题二**
	  >
	  > 在二叉树中搜索所有值为 7 的节点，**返回根节点到这些节点的路径**。
	- **解题思路**：在例题一代码的基础上，我们需要借助一个列表 `path` 记录访问过的节点路径。当访问到值为 7 的节点时，则复制 `path` 并添加进结果列表 `res` 。遍历完成后，`res` 中保存的就是所有的解。
	- ```
	  /* 前序遍历：例题二 */
	  function preOrder(root, path, res) {
	      if (root === null) {
	          return;
	      }
	      // 尝试
	      path.push(root);
	      if (root.val === 7) {
	          // 记录解
	          res.push([...path]);
	      }
	      preOrder(root.left, path, res);
	      preOrder(root.right, path, res);
	      // 回退
	      path.pop();
	  }
	  ```
	- 在每次“尝试”中，我们通过将当前节点添加进 `path` 来记录路径；而在“回退”前，我们需要将该节点从 `path` 中弹出，**以恢复本次尝试之前的状态**。换句话说，**我们可以将尝试和回退理解为“前进”与“撤销”**，两个操作是互为相反的。
- ##   剪枝
	- 复杂的回溯问题通常包含一个或多个约束条件，**约束条件通常可用于“剪枝”**。
	- > ❓ **例题三**
	  >
	  > 在二叉树中搜索所有值为 7 的节点，返回根节点到这些节点的路径，**路径中不能包含值为 3 的节点**。
	- **解题思路**：在例题二的基础上添加剪枝操作，当遇到值为 3 的节点时，则终止继续搜索。
	- ```
	  /* 前序遍历：例题三 */
	  function preOrder(root, path, res) {
	      // 剪枝
	      if (root === null || root.val === 3) {
	          return;
	      }
	      // 尝试
	      path.push(root);
	      if (root.val === 7) {
	          // 记录解
	          res.push([...path]);
	      }
	      preOrder(root.left, path, res);
	      preOrder(root.right, path, res);
	      // 回退
	      path.pop();
	  }
	  ```
- ## 常用术语
	- 为了更清晰地分析算法问题，我们总结一下回溯算法中常用术语的含义，并对照例题三给出对应示例。
	- |**名词**|**定义**|**例题三**|
	  |--|--|--|
	  |解 Solution|解是满足问题特定条件的答案。回溯算法的目标是找到一个或多个满足条件的解|根节点到节点 $7$ 的所有路径，且路径中不包含值为 $3$ 的节点|
	  |状态 State|状态表示问题在某一时刻的情况，包括已经做出的选择|当前已访问的节点路径，即 path 节点列表|
	  |约束条件 Constraint|约束条件是问题中限制解的可行性的条件，通常用于剪枝|要求路径中不能包含值为 $3$ 的节点|
	  |尝试 Attempt|尝试是在搜索过程中，根据当前状态和可用选择来探索解空间的过程。尝试包括做出选择，更新状态，检查是否为解|递归访问左（右）子节点，将节点添加进 path ，判断节点的值是否为 $7$|
	  |回退 Backtracking|回退指在搜索中遇到到不满足约束条件或无法继续搜索的状态时，撤销前面做出的选择，回到上一个状态|当越过叶结点、结束结点访问、遇到值为 $3$ 当越过叶结点、结束结点访问、遇到值为|
	  |剪枝 Pruning|剪枝是根据问题特性和约束条件避免无意义的搜索路径的方法，可提高搜索效率|当遇到值为 $3$ 的节点时，则终止继续搜索|
- ## 框架代码
	- 回溯算法可用于解决许多搜索问题、约束满足问题和组合优化问题。为提升代码通用性，我们希望将回溯算法的“[[#green]]==尝试、回退、剪枝==”的主体框架提炼出来。
	- 设 `state` 为问题的当前状态，`choices` 表示当前状态下可以做出的选择，则可得到以下回溯算法的框架代码。
	- ```
	  /* 回溯算法框架 */
	  function backtrack(state, choices, res) {
	      // 判断是否为解
	      if (isSolution(state)) {
	          // 记录解
	          recordSolution(state, res);
	          return;
	      }
	      // 遍历所有选择
	      for (let choice of choices) {
	          // 剪枝：判断选择是否合法
	          if (isValid(state, choice)) {
	              // 尝试：做出选择，更新状态
	              makeChoice(state, choice);
	              backtrack(state, choices, res);
	              // 回退：撤销选择，恢复到之前的状态
	              undoChoice(state, choice);
	          }
	      }
	  }
	  ```
- ## 典型例题
	- **搜索问题**：这类问题的目标是找到满足特定条件的解决方案。
		- 全排列问题：给定一个集合，求出其所有可能的排列组合。
		- 子集和问题：给定一个集合和一个目标和，找到集合中所有和为目标和的子集。
		  汉诺塔问题：给定三个柱子和一系列大小不同的圆盘，要求将所有圆盘从一个柱子移动到另一个柱子，每次只能移动一个圆盘，且不能将大圆盘放在小圆盘上。
	- **约束满足问题**：这类问题的目标是找到满足所有约束条件的解。
		- $n$皇后：在 $n×n$ 的棋盘上放置 $n$ 个皇后，使得它们互不攻击。
		  数独：在 9×9 的网格中填入数字 1 ~ 9 ，使得每行、每列和每个 3×3 子网格中的数字不重复。
		  图着色问题：给定一个无向图，用最少的颜色给图的每个顶点着色，使得相邻顶点颜色不同。
	- **组合优化问题**：这类问题的目标是在一个组合空间中找到满足某些条件的最优解。
		- 0-1 背包问题：给定一组物品和一个背包，每个物品有一定的价值和重量，要求在背包容量限制内，选择物品使得总价值最大。
		  旅行商问题：在一个图中，从一个点出发，访问所有其他点恰好一次后返回起点，求最短路径。
		  最大团问题：给定一个无向图，找到最大的完全子图，即子图中的任意两个顶点之间都有边相连。
	- > 请注意，回溯算法通常不是解决组合优化问题的最优方法。0-1 背包问题通常使用**动态规划**解决；旅行商是一个 NP-Hard 问题，常用解决方法有**遗传算法**和**蚁群算法**等；最大团问题是图轮中的一个经典 NP-Hard 问题，通常用**贪心算法**等启发式算法来解决。
	-
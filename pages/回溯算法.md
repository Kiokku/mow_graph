- > https://www.hello-algo.com/chapter_backtracking/backtracking_algorithm/
-
- **「回溯算法 Backtracking Algorithm」**是一种通过**穷举**来解决问题的方法，它的核心思想是从一个初始状态出发，暴力搜索所有可能的解决方案，当遇到正确的解则将其记录，直到找到解或者尝试了所有可能的选择都无法找到解为止。
- 回溯算法通常采用**「深度优先搜索 DFS」**来遍历解空间。在二叉树章节中，我们提到前序、中序和后序遍历都属于深度优先搜索。下面，我们将从前序遍历入手，逐步了解回溯算法的工作原理。
- > ❓ **例题一**
  >
  > 给定一个二叉树，搜索并记录所有值为 7 的节点，返回节点列表。
- **解题思路**：前序遍历这颗树，并判断当前节点的值是否为 7 ，若是则将该节点的值加入到结果列表 `res` 之中。
- ```
  /* 前序遍历：例题一 */
  function preOrder(root, res) {
      if (root === null) {
          return;
      }
      if (root.val === 7) {
          // 记录解
          res.push(root);
      }
      preOrder(root.left, res);
      preOrder(root.right, res);
  }
  ```
- ## 尝试与回退
	- **之所以称之为回溯算法，是因为该算法在搜索解空间时会采用“尝试”与“回退”的策略**。当算法在搜索过程中遇到某个状态无法继续前进或无法得到满足条件的解时，它会撤销上一步的选择，退回到之前的状态，并尝试其他可能的选择。
	- 值得说明的是，[[#red]]==**回退并不等价于函数返回**==。为解释这一点，我们对例题一稍作拓展。
	- > ❔ **例题二**
	  >
	  > 在二叉树中搜索所有值为 7 的节点，**返回根节点到这些节点的路径**。
	- **解题思路**：在例题一代码的基础上，我们需要借助一个列表 `path` 记录访问过的节点路径。当访问到值为 7 的节点时，则复制 `path` 并添加进结果列表 `res` 。遍历完成后，`res` 中保存的就是所有的解。
	- ```
	  /* 前序遍历：例题二 */
	  function preOrder(root, path, res) {
	      if (root === null) {
	          return;
	      }
	      // 尝试
	      path.push(root);
	      if (root.val === 7) {
	          // 记录解
	          res.push([...path]);
	      }
	      preOrder(root.left, path, res);
	      preOrder(root.right, path, res);
	      // 回退
	      path.pop();
	  }
	  ```
	- 在每次“尝试”中，我们通过将当前节点添加进 `path` 来记录路径；而在“回退”前，我们需要将该节点从 `path` 中弹出，**以恢复本次尝试之前的状态**。换句话说，**我们可以将尝试和回退理解为“前进”与“撤销”**，两个操作是互为相反的。
- ##   剪枝
	- 复杂的回溯问题通常包含一个或多个约束条件，**约束条件通常可用于“剪枝”**。
	- > ❓ **例题三**
	  >
	  > 在二叉树中搜索所有值为 7 的节点，返回根节点到这些节点的路径，**路径中不能包含值为 3 的节点**。
	- **解题思路**：在例题二的基础上添加剪枝操作，当遇到值为 3 的节点时，则终止继续搜索。
	- ```
	  /* 前序遍历：例题三 */
	  function preOrder(root, path, res) {
	      // 剪枝
	      if (root === null || root.val === 3) {
	          return;
	      }
	      // 尝试
	      path.push(root);
	      if (root.val === 7) {
	          // 记录解
	          res.push([...path]);
	      }
	      preOrder(root.left, path, res);
	      preOrder(root.right, path, res);
	      // 回退
	      path.pop();
	  }
	  ```
- ## 常用术语
	- 为了更清晰地分析算法问题，我们总结一下回溯算法中常用术语的含义，并对照例题三给出对应示例。
	- |**名词**|**定义**|**例题三**|
	  |--|--|--|
	  |解 Solution|解是满足问题特定条件的答案。回溯算法的目标是找到一个或多个满足条件的解|根节点到节点 $7$ 的所有路径，且路径中不包含值为 $3$ 的节点|
	  |状态 State|状态表示问题在某一时刻的情况，包括已经做出的选择|当前已访问的节点路径，即 path 节点列表|
	  |约束条件 Constraint|约束条件是问题中限制解的可行性的条件，通常用于剪枝|要求路径中不能包含值为 $3$ 的节点|
	  |尝试 Attempt|尝试是在搜索过程中，根据当前状态和可用选择来探索解空间的过程。尝试包括做出选择，更新状态，检查是否为解|递归访问左（右）子节点，将节点添加进 path ，判断节点的值是否为 $7$|
	  |回退 Backtracking|回退指在搜索中遇到到不满足约束条件或无法继续搜索的状态时，撤销前面做出的选择，回到上一个状态|当越过叶结点、结束结点访问、遇到值为 $3$ 当越过叶结点、结束结点访问、遇到值为|
	  |剪枝 Pruning|剪枝是根据问题特性和约束条件避免无意义的搜索路径的方法，可提高搜索效率|当遇到值为 $3$ 的节点时，则终止继续搜索|
	-
- > https://www.hello-algo.com/chapter_dynamic_programming/dp_problem_features/
-
- **「动态规划」**最常用来求解最优方案问题，例如寻找最短路径、最大利润、最少时间等。**这类问题不仅包含重叠子问题，往往还具有另外两大特性：最优子结构、无后效性**。
- ## 最优子结构
	- > ❓ **爬楼梯最小代价**
	  >
	  > 给定一个楼梯，你每步可以上 1 阶或者 2 阶，每一阶楼梯上都贴有一个非负整数，表示你在该台阶所需要付出的代价。给定一个非负整数数组 $cost$ ，其中 $cost[i]$ 表示在第 $i$ 个台阶需要付出的代价，$cost[0]$ 为地面起始点。请计算最少需要付出多少代价才能到达顶部？
	- 设 $dp[i]$ 为爬到第 $i$ 阶累计付出的代价，由于第 $i$ 阶只可能从 $i-1$ 阶或 $i-2$ 阶走来，因此 $dp[i]$ 只可能等于 $dp[i−1]$+$cost[i]$ 或 $dp[i−2]+cost[i]$ 。为了尽可能减少代价，我们应该选择两者中较小的那一个，即：
	- $$dp[i]=\min(dp[i-1],dp[i-2])+cost[i]$$
	- **「最优子结构」**的含义：**原问题的最优解是从子问题的最优解构建得来的**。
	- 根据以上**状态转移方程**，以及初始状态 $dp[1]=cost[1]$ , $dp[2]=cost[2]$ ，我们可以得出动态规划解题代码。
	- ```
	  /* 爬楼梯最小代价：动态规划 */
	  function minCostClimbingStairsDP(cost = []) {
	      let n = cost.length - 1;
	      if (n == 1 || n == 2)
	          return cost[n];
	      // 初始化 dp 表，用于存储子问题的解
	      cosnt dp = new Array(n + 1);
	      // 初始状态：预设最小子问题的解
	      dp[1] = cost[1];
	      dp[2] = cost[2];
	      // 状态转移：从较小子问题逐步求解较大子问题
	      for (let i = 3; i <= n; i++) {
	          dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i];
	      }
	      return dp[n];
	  }
	  ```
	- 这道题同样也可以进行状态压缩，将一维压缩至零维，使得空间复杂度从$O(n)$降低至$O(1)$
- ## 无后效性
	- **「无后效性」**是动态规划能够有效解决问题的重要特性之一，定义为：**给定一个确定的状态，它的未来发展只与当前状态有关，而与当前状态过去所经历过的所有状态无关**。
	-
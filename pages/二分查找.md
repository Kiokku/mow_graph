- > https://www.hello-algo.com/chapter_searching/binary_search/
-
- **「二分查找 Binary Search」**是一种基于分治思想的高效搜索算法。它利用数据的有序性，每轮减少一半搜索范围，直至找到目标元素或搜索区间为空为止。
- > **Question**
  > 给定一个长度为 $n$ 的数组 `nums` ，元素按从小到大的顺序排列，数组不包含重复元素。请查找并返回元素 `target` 在该数组中的索引。若数组不包含该元素，则返回 −1 。
- 对于上述问题，我们先初始化指针 $i=0$ 和 $j=n−1$ ，分别指向数组首元素和尾元素，代表搜索区间 $[0,n−1]$ 。其中，中括号表示“闭区间”，即包含边界值本身。
- 接下来，循环执行以下两个步骤：
	- 1. 计算中点索引 $m=⌊(i+j)/2⌋$ ，其中 ⌊ ⌋ 表示向下取整操作。
	- 2. 判断 `nums[m]` 和 `target` 的大小关系，分为三种情况：
		- a. 当 `nums[m] < target` 时，说明 `target` 在区间 $[m+1,j]$ 中，因此执行 $i=m+1$ ；
		- b. 当 `nums[m] > target` 时，说明 `target` 在区间 $[i,m−1]$ 中，因此执行 $j=m−1$ ；
		- c. 当 `nums[m] = target` 时，说明找到 `target` ，因此返回索引 $m$ ；
- 若数组不包含目标元素，搜索区间最终会缩小为空。此时返回 −1 。
- 值得注意的是，由于 $i$ 和 $j$ 都是 `int` 类型，**因此 $i+j$ 可能会超出 `int` 类型的取值范围**。[[#blue]]==为了避免大数越界，我们通常采用公式== $m=⌊i+(j−i)/2⌋$ [[#blue]]==来计算中点。==
- ```
  /* 二分查找（双闭区间） */
  function binarySearch(nums, target) {
      // 初始化双闭区间 [0, n-1] ，即 i, j 分别指向数组首元素、尾元素
      let i = 0,
          j = nums.length - 1;
      // 循环，当搜索区间为空时跳出（当 i > j 时为空）
      while (i <= j) {
          // 计算中点索引 m ，使用 parseInt() 向下取整
          const m = parseInt(i + (j - i) / 2);
          if (nums[m] < target)
              // 此情况说明 target 在区间 [m+1, j] 中
              i = m + 1;
          else if (nums[m] > target)
              // 此情况说明 target 在区间 [i, m-1] 中
              j = m - 1;
          else return m; // 找到目标元素，返回其索引
      }
      // 未找到目标元素，返回 -1
      return -1;
  }
  
  ```
- 时间复杂度为 $O(\log⁡{n})$ 。每轮缩小一半区间，因此二分循环次数为 $\log 。
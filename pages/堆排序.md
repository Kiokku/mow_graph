- > https://www.hello-algo.com/chapter_sorting/heap_sort/
-
- **「堆排序 Heap Sort」**是一种基于堆数据结构实现的高效排序算法。我们可以利用已经学过的“建堆操作”和“元素出堆操作”实现堆排序：
	- 1. 输入数组并建立小顶堆，此时最小元素位于堆顶。
	- 2. 不断执行出堆操作，依次记录出堆元素，即可得到从小到大排序的序列。
- 以上方法虽然可行，但需要借助一个额外数组来保存弹出的元素，比较浪费空间。在实际中，我们通常使用一种更加优雅的实现方式。
- ## 算法流程
	- 设数组的长度为$n$，堆排序的流程如下：
		- 1. 输入数组并建立大顶堆。完成后，最大元素位于堆顶。
		- 2. 将堆顶元素（第一个元素）与堆底元素（最后一个元素）交换。完成交换后，堆的长度减 1 ，已排序元素数量加 1 。
		- 3. 从堆顶元素开始，从顶到底执行堆化操作（Sift Down）。完成堆化后，堆的性质得到修复。
		- 4. 循环执行第 `2.` 和 `3.` 步。循环 $n−1$ 轮后，即可完成数组排序。
	- 在代码实现中，我们使用了与堆章节相同的从顶至底堆化（Sift Down）的函数。值得注意的是，由于堆的长度会随着提取最大元素而减小，因此我们需要给 Sift Down 函数添加一个长度参数 $n$ ，用于指定堆的当前有效长度。
	- ```
	  /* 堆的长度为 n ，从节点 i 开始，从顶至底堆化 */
	  function siftDown(nums, n, i) {
	      while (true) {
	          // 判断节点 i, l, r 中值最大的节点，记为 ma
	          let l = 2 * i + 1;
	          let r = 2 * i + 2;
	          let ma = i;
	          if (l < n && nums[l] > nums[ma]) {
	              ma = l;
	          }
	          if (r < n && nums[r] > nums[ma]) {
	              ma = r;
	          }
	          // 若节点 i 最大或索引 l, r 越界，则无需继续堆化，跳出
	          if (ma === i) {
	              break;
	          }
	          // 交换两节点
	          [nums[i], nums[ma]] = [nums[ma], nums[i]];
	          // 循环向下堆化
	          i = ma;
	      }
	  }
	  
	  /* 堆排序 */
	  function heapSort(nums) {
	      // 建堆操作：堆化除叶节点以外的其他所有节点
	      for (let i = Math.floor(nums.length / 2) - 1; i >= 0; i--) {
	          siftDown(nums, nums.length, i);
	      }
	      // 从堆中提取最大元素，循环 n-1 轮
	      for (let i = nums.length - 1; i > 0; i--) {
	          // 交换根节点与最右叶节点（即交换首元素与尾元素）
	          [nums[0], nums[i]] = [nums[i], nums[0]];
	          // 以根节点为起点，从顶至底进行堆化
	          siftDown(nums, i, 0);
	      }
	  }
	  ```
	-
	-
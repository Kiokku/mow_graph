- > https://www.hello-algo.com/chapter_graph/graph_operations/
-
- 图的基础操作可分为对「边」的操作和对「顶点」的操作。在「邻接矩阵」和「邻接表」两种表示方法下，实现方式有所不同。
  background-color:: yellow
- ## 基于邻接矩阵的实现
	- 给定一个顶点数量为 $n$ 的**无向图**，则有：
		- **添加或删除边**：直接在邻接矩阵中修改指定的边即可，使用 $O(1)$ 时间。而由于是无向图，因此[[#blue]]==需要同时更新两个方向的边==。
		- **添加顶点**：在邻接矩阵的尾部添加一行一列，并全部填 $0$ 即可，使用 $O(n)$ 时间。
		- **删除顶点**：在邻接矩阵中删除一行一列。当删除首行首列时达到最差情况，需要将 $(n−1)^2$ 个元素“向左上移动”，从而使用 $O(n^2)$ 时间。
		- **初始化**：传入 $n$ 个顶点，初始化长度为 $n$ 的顶点列表 `vertices` ，使用 $O(n)$ 时间；初始化 $n×n$ 大小的邻接矩阵 `adjMat` ，使用 $O(n^2)$ 时间。
	- ![image.png](../assets/image_1686808445997_0.png)
	- ![image.png](../assets/image_1686808469281_0.png)
	- ![image.png](../assets/image_1686808488515_0.png)
	- ![image.png](../assets/image_1686808508641_0.png)
	- ![image.png](../assets/image_1686808519771_0.png)
	- 以下是基于邻接矩阵表示图的实现代码。
	- ```
	  /* 基于邻接矩阵实现的无向图类 */
	  class GraphAdjMat {
	      vertices; // 顶点列表，元素代表“顶点值”，索引代表“顶点索引”
	      adjMat; // 邻接矩阵，行列索引对应“顶点索引”
	  
	      /* 构造函数 */
	      constructor(vertices, edges) {
	          this.vertices = [];
	          this.adjMat = [];
	          // 添加顶点
	          for (const val of vertices) {
	              this.addVertex(val);
	          }
	          // 添加边
	          // 请注意，edges 元素代表顶点索引，即对应 vertices 元素索引
	          for (const e of edges) {
	              this.addEdge(e[0], e[1]);
	          }
	      }
	  
	      /* 获取顶点数量 */
	      size() {
	          return this.vertices.length;
	      }
	  
	      /* 添加顶点 */
	      addVertex(val) {
	          const n = this.size();
	          // 向顶点列表中添加新顶点的值
	          this.vertices.push(val);
	          // 在邻接矩阵中添加一行
	          const newRow = [];
	          for (let j = 0; j < n; j++) {
	              newRow.push(0);
	          }
	          this.adjMat.push(newRow);
	          // 在邻接矩阵中添加一列
	          for (const row of this.adjMat) {
	              row.push(0);
	          }
	      }
	  
	      /* 删除顶点 */
	      removeVertex(index) {
	          if (index >= this.size()) {
	              throw new RangeError('Index Out Of Bounds Exception');
	          }
	          // 在顶点列表中移除索引 index 的顶点
	          this.vertices.splice(index, 1);
	  
	          // 在邻接矩阵中删除索引 index 的行
	          this.adjMat.splice(index, 1);
	          // 在邻接矩阵中删除索引 index 的列
	          for (const row of this.adjMat) {
	              row.splice(index, 1);
	          }
	      }
	  
	      /* 添加边 */
	      // 参数 i, j 对应 vertices 元素索引
	      addEdge(i, j) {
	          // 索引越界与相等处理
	          if (i < 0 || j < 0 || i >= this.size() || j >= this.size() || i === j) {
	              throw new RangeError('Index Out Of Bounds Exception');
	          }
	          // 在无向图中，邻接矩阵沿主对角线对称，即满足 (i, j) == (j, i)
	          this.adjMat[i][j] = 1;
	          this.adjMat[j][i] = 1;
	      }
	  
	      /* 删除边 */
	      // 参数 i, j 对应 vertices 元素索引
	      removeEdge(i, j) {
	          // 索引越界与相等处理
	          if (i < 0 || j < 0 || i >= this.size() || j >= this.size() || i === j) {
	              throw new RangeError('Index Out Of Bounds Exception');
	          }
	          this.adjMat[i][j] = 0;
	          this.adjMat[j][i] = 0;
	      }
	  
	      /* 打印邻接矩阵 */
	      print() {
	          console.log('顶点列表 = ', this.vertices);
	          console.log('邻接矩阵 =', this.adjMat);
	      }
	  }
	  ```
	-
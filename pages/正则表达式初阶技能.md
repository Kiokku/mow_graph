- ## 贪婪模式与非贪婪模式
	- 默认情况下, 所有的限定词都是贪婪模式, 表示尽可能多的去捕获字符; 而在[[#blue]]==限定词后增加?==, 则是非贪婪模式, 表示尽可能少的去捕获字符. 如下:
	- ```
	  var str = "aaab",
	      reg1 = /a+/, //贪婪模式
	      reg2 = /a+?/;//非贪婪模式
	  console.log(str.match(reg1)); //["aaa"], 由于是贪婪模式, 捕获了所有的a
	  console.log(str.match(reg2)); //["a"], 由于是非贪婪模式, 只捕获到第一个a
	  ```
	- [[#blue]]==区间量词的非贪婪模式==
		- 一般情况下, 非贪婪模式, 我们使用的是`*?`, 或 `+?` 这种形式, 还有一种是 `{n,m}?`.
		- 区间量词”{n,m}” 也是匹配优先, 虽有匹配次数上限, 但是在到达上限之前, 它依然是尽可能多的匹配, 而”{n,m}?” 则表示在区间范围内, 尽可能少的匹配.
		- **需要注意的是**:
			- 1. 能达到同样匹配结果的贪婪与非贪婪模式, 通常是[[#blue]]==贪婪模式的匹配效率较高==.
			  2. 所有的非贪婪模式, 都可以通过修改量词修饰的子表达式, 转换为贪婪模式.
			  3. 贪婪模式可以与`固化分组`(后面会讲到)结合，提升匹配效率，而非贪婪模式却不可以.
- ## 分组
	- 正则的分组主要通过小括号来实现, 括号包裹的子表达式作为一个分组, 括号后[[#blue]]==可以紧跟限定词表示重复次数==. 如下, 小括号内包裹的abc便是一个分组:
		- ```
		  /(abc)+/.test("abc123") == true
		  ```
	- 一般来说, 分组是为了方便的表示重复次数, 除此之外, 还有一个作用就是用于捕获.
	- [[#blue]]==捕获性分组==
		- 捕获性分组, 通常由一对小括号加上子表达式组成. 捕获性分组会创建反向引用, 每个反向引用都由一个编号或名称来标识, js中主要是通过 `$+编号` 或者 `\+编号` 表示法进行引用. 如下便是一个捕获性分组的例子.
			- ```
			  var color = "#808080";
			  var output = color.replace(/#(\d+)/,"$1"+"~~");//自然也可以写成 "$1~~"
			  console.log(RegExp.$1);//808080
			  console.log(output);//808080~~
			  ```
			- 以上, (\d+) 表示一个捕获性分组, `RegExp.$1` 指向该分组捕获的内容. `$+编号` 只[[#blue]]==能在正则表达式之外使用==.
	- [[#blue]]==反向引用==
		- 能在正则表达式内部使用的引用只有『反向引用』，其格式为`\+数字` ，通常用于匹配不同位置相同部分的子串。如下：
			- ```
			  var url = "www.google.google.com";
			  var re = /([a-z]+)\.\1/;
			  console.log(url.replace(re,"$1"));//"www.google.com"
			  ```
			- 以上，相同部分的”google”字符串只被替换一次。
		- 实例之后，我们来看看反向引用的原理。
		- > 正则表达式匹配时，各个捕获性分组匹配到的内容，会依次保存在内存中一个特定的组里，通过`\+数字`的方式可以在正则中引用组里的内容，这种引用称作**反向引用**。捕获性分组匹配成功之前，它的内容的是不确定的，一旦匹配成功，组里的内容也就确定了。
		- 反向引用中`\n`指向正则表达式前面第n个捕获性分组匹配到的内容，这里面有一个问题，对于子表达式`\12`，有下面两种可能：
			- 1. 指向第1个捕获性分组匹配到的内容，同时匹配普通字符2，目前IE浏览器按照这种方式解析正则。
			  2. 指向第12个捕获性分组匹配到的内容，目前非IE等现代浏览器都是这样解析正则的。
		- 有关反向引用，其他非JavaScript语言中，还没有仔细测试，猜测跟现代浏览器的处理方式一致。为避免各语言或者浏览器解析不一致，因此建议**反向引用不要索引大于9的捕获性分组**。不仅如此，反向引用如果不存在，正则将会匹配失败。
		- **反向引用常用来匹配重复出现的字符串，而不是重复出现的子表达式，这点要尤为注意。**因此如果想要匹配4个或2个数字的话，使用如下正则表达式是万万不行的。
			- ```
			  "1234567890".match(/(\d){4}|\1{2}/g); // ["1234", "5678", "", "", ""]
			  ```
			- 以上正则表达式，想用反向引用`\1`代替前面的捕获性分组`\d`，这是不可行的。修饰符g表示全文查找，因此前两次匹配到了 “1234” 和 “5678”，此时正则引擎的指针处于数字8的后面，再往后匹配显然子表达式`(\d){4}`无法匹配了，此时[[#blue]]==第一个捕获组匹配到空字符串，那么反向引用`\1`将指向空字符串==，也就是一个位置（有些类似后面将要讲到的零宽断言），对于”890”子字符串，8、9或0后面共有3个位置可供反向引用匹配，故最终又匹配到三个空字符串。正确的正则表达式如下：
			- ```
			  "1234567890".match(/\d{4}|\d{2}/g); // ["1234", "5678", "90"]
			  ```
	- [[#blue]]==非捕获性分组==
		- 非捕获性分组, 通常由一对括号加上”?:”加上子表达式组成, 非捕获性分组不会创建反向引用, 就好像没有括号一样. 如下:
		- ```
		  var color = "#808080";
		  var output = color.replace(/#(?:\d+)/,"$1"+"~~");
		  console.log(RegExp.$1);//""
		  console.log(output);//$1~~
		  ```
		- 以上, (?:\d+) 表示一个非捕获性分组, 由于分组不捕获任何内容, 所以, `RegExp.$1` 就指向了空字符串.
		- 同时, 由于`$1` 的反向引用不存在, 因此最终它被当成了普通字符串进行替换.
		- 实际上, 捕获性分组和无捕获性分组在搜索效率方面也没什么不同, 没有哪一个比另一个更快.
	- [[#blue]]==命名分组==
		- 语法: (?…)
		- 命名分组也是**捕获性分组**, 它将匹配的字符串捕获到一个组名称或编号名称中, 在获得匹配结果后, 可通过分组名进行获取. 如下是一个python的命名分组的例子.
		- ```
		  import re
		  data = "#808080"
		  regExp = r"#(?P<one>\d+)"
		  replaceString = "\g<one>" + "~~"
		  print re.sub(regExp,replaceString,data) # 808080~~
		  ```
		- 与python不同的是, [[#red]]==javaScript 中并不支持命名分组==.
	- [[#blue]]==固化分组==
		- 固化分组, 又叫原子组,语法: (?>…).
		- javaScript, java 和 python中并不支持固化分组的语法.
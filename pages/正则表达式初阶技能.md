- ## 贪婪模式与非贪婪模式
	- 默认情况下, 所有的限定词都是贪婪模式, 表示尽可能多的去捕获字符; 而在[[#blue]]==限定词后增加?==, 则是非贪婪模式, 表示尽可能少的去捕获字符. 如下:
	- ```
	  var str = "aaab",
	      reg1 = /a+/, //贪婪模式
	      reg2 = /a+?/;//非贪婪模式
	  console.log(str.match(reg1)); //["aaa"], 由于是贪婪模式, 捕获了所有的a
	  console.log(str.match(reg2)); //["a"], 由于是非贪婪模式, 只捕获到第一个a
	  ```
	- [[#blue]]==区间量词的非贪婪模式==
		- 一般情况下, 非贪婪模式, 我们使用的是`*?`, 或 `+?` 这种形式, 还有一种是 `{n,m}?`.
		- 区间量词”{n,m}” 也是匹配优先, 虽有匹配次数上限, 但是在到达上限之前, 它依然是尽可能多的匹配, 而”{n,m}?” 则表示在区间范围内, 尽可能少的匹配.
		- **需要注意的是**:
			- 1. 能达到同样匹配结果的贪婪与非贪婪模式, 通常是[[#blue]]==贪婪模式的匹配效率较高==.
			  2. 所有的非贪婪模式, 都可以通过修改量词修饰的子表达式, 转换为贪婪模式.
			  3. 贪婪模式可以与`固化分组`(后面会讲到)结合，提升匹配效率，而非贪婪模式却不可以.
- ## 分组
	- 正则的分组主要通过小括号来实现, 括号包裹的子表达式作为一个分组, 括号后[[#blue]]==可以紧跟限定词表示重复次数==. 如下, 小括号内包裹的abc便是一个分组:
		- ```
		  /(abc)+/.test("abc123") == true
		  ```
	- 一般来说, 分组是为了方便的表示重复次数, 除此之外, 还有一个作用就是用于捕获.
	- [[#blue]]==捕获性分组==
		- 捕获性分组, 通常由一对小括号加上子表达式组成. 捕获性分组会创建反向引用, 每个反向引用都由一个编号或名称来标识, js中主要是通过 `$+编号` 或者 `\+编号` 表示法进行引用. 如下便是一个捕获性分组的例子.
			- ```
			  var color = "#808080";
			  var output = color.replace(/#(\d+)/,"$1"+"~~");//自然也可以写成 "$1~~"
			  console.log(RegExp.$1);//808080
			  console.log(output);//808080~~
			  ```
			- 以上, (\d+) 表示一个捕获性分组, `RegExp.$1` 指向该分组捕获的内容. `$+编号` 只[[#blue]]==能在正则表达式之外使用==.
	- [[#blue]]==反向引用==
		- 能在正则表达式内部使用的引用只有『反向引用』，其格式为`\+数字` ，通常用于匹配不同位置相同部分的子串。如下：
			- ```
			  var url = "www.google.google.com";
			  var re = /([a-z]+)\.\1/;
			  console.log(url.replace(re,"$1"));//"www.google.com"
			  ```
			- 以上，相同部分的”google”字符串只被替换一次。
		- 实例之后，我们来看看反向引用的原理。
		- > 正则表达式匹配时，各个捕获性分组匹配到的内容，会依次保存在内存中一个特定的组里，通过`\+数字`的方式可以在正则中引用组里的内容，这种引用称作**反向引用**。捕获性分组匹配成功之前，它的内容的是不确定的，一旦匹配成功，组里的内容也就确定了。
		-
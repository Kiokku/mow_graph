## Embedding (向量嵌入)
	- Embedding 是一种将**非结构化数据**（如文本、图像、音频）转换为**稠密、低维的数值向量**的技术。
	- **核心思想：**
		- 将复杂信息（如一个词、一句话、一张图）映射到一个多维空间中的一个点（向量）。
		- 在这个向量空间中，**语义或概念上相似的对象，其对应的向量在空间中的距离也更近**（通过余弦相似度或欧氏距离衡量）。
		- 向量中的每个维度（数值）代表了原始数据某些隐含的、有意义的特征（这些特征通常是人类难以直接解释的，但对机器学习模型至关重要）。
- ## RAG (Retrieval-Augmented Generation - 检索增强生成)
	- RAG 是一种用于**大型语言模型**的技术架构。它的核心思想是：**在 LLM 生成答案之前，先从外部知识库中检索相关的信息片段，并将这些信息片段连同用户的原始问题一起“喂”给 LLM，让 LLM 基于这些检索到的上下文信息来生成更准确、更相关、事实性更强的答案。**
	- ### **RAG 如何工作？**
		- **用户提问：** 用户提出一个问题。
		- **检索：**
			- 将用户的**问题**通过 **Embedding 模型**转换成**查询向量**。
			- 在一个**向量数据库**中，存储了预先准备好的外部知识库（文档、网页、数据库记录等）的**内容片段**及其对应的 **Embedding 向量**。
			- 使用**相似性搜索算法**（如余弦相似度）在向量数据库中查找与查询向量**最相似的 K 个内容片段**（通常是文本段落）。这些片段被认为与用户问题最相关。
		- **增强：** 将检索到的 K 个最相关的文本片段（上下文）**与用户的原始问题一起**，组合成一个新的、更丰富的提示。
		- **生成：** 将这个组合后的提示输入给 **LLM**。LLM 的任务变成了：“基于提供的上下文信息，回答用户的问题。” LLM 基于检索到的可靠上下文生成最终的答案。
- ## 服务器发送事件（SSE - Server-Sent Events）是什么？
	- SSE 是一种**基于 HTTP** 的协议，允许服务器**主动**、**单向**地向客户端（通常是 Web 浏览器）推送数据更新。它的核心思想是建立一个持久化的 HTTP 连接，服务器可以随时通过这个连接发送新的数据片段（称为“事件”）给客户端。
	- ### 关键特性
		- **单向通信：** 数据流只从服务器流向客户端。客户端无法通过 SSE 连接向服务器发送数据（如果需要发送数据，必须使用另一个独立的 HTTP 请求，如 AJAX）。
		- **基于 HTTP/HTTPS：** 使用标准的 HTTP 协议，利用其长连接特性（如 HTTP/1.1 的 `keep-alive` 或 HTTP/2 的流）。这使得它：
			- 易于集成到现有基于 HTTP 的基础设施中。
			- 天然支持 HTTP 的特性，如身份验证、Cookies、CORS 等。
			- 更容易通过防火墙和代理。
		- **文本协议：** 数据以纯文本格式（通常是 UTF-8）传输，通常是结构化的文本（如 JSON 或自定义格式）。它不直接支持传输二进制数据（需要 Base64 编码）。
		- **自动重连：** 协议内置了重连机制。如果连接意外中断，客户端会自动尝试重新连接。
		- **事件 ID：** 服务器可以发送一个事件 ID (`id:`)。如果连接断开并重连，客户端会在 HTTP 请求头 `Last-Event-ID` 中自动发送最后一个接收到的事件 ID，服务器可以据此决定从哪个点开始恢复发送数据，避免数据丢失或重复。
		- **事件类型：** 服务器可以为不同类型的事件指定一个名称 (`event:`)，客户端可以监听特定类型的事件。
		- **简单易用：** 在浏览器端，使用 `EventSource` API 非常简洁。
	- ### 工作原理
		- 客户端（浏览器）使用 JavaScript 的 `EventSource` 对象创建一个到指定服务器端点的连接。
			- ```
			  const eventSource = new EventSource('/updates');
			  ```
		- 服务器接收到这个 HTTP GET 请求，保持连接打开（长连接），并将响应的 `Content-Type` 设置为 `text/event-stream`。
		- 服务器准备好新数据时，通过这个打开的连接发送格式化的消息。每条消息由字段组成，以 `\n\n` 结束：
			- ```
			  event: stockUpdate
			  id: 789
			  data: {"symbol": "AAPL", "price": 182.35}
			  retry: 5000
			  
			  data: This is a simple message
			  ```
			- `event:` (可选)：事件类型名。
			- `id:` (可选)：事件 ID。
			- `data:`：消息内容。可以有多行 `data:`，最终内容将是这些行的拼接（用 `\n` 连接）。
			- `retry:` (可选)：建议客户端在断开连接后等待多少毫秒重连。
		- 客户端通过监听 `EventSource` 对象上的事件来处理接收到的消息：
			- ```
			  eventSource.addEventListener('stockUpdate', function(event) {
			    const data = JSON.parse(event.data); // 解析 data 字段内容
			    console.log('Received stock update:', data);
			  });
			  eventSource.onmessage = function(event) { // 监听没有指定 event 类型的消息
			    console.log('Generic message:', event.data);
			  };
			  eventSource.onerror = function(event) {
			    console.error('Error with SSE connection', event);
			  };
			  ```
	- ### SSE 与 WebSocket 的区别
		- | 特性 | 服务器发送事件 (SSE) | WebSocket |
		  | **通信方向** | **单向 (Server -> Client)** | **双向 (Full-Duplex)** |
		  | **底层协议** | **HTTP/HTTPS** | **独立的 TCP 协议 (****ws://****, ****wss://****)** |
		  | **连接建立** | 标准的 HTTP GET 请求 | 专门的 HTTP Upgrade 握手 (`Connection: upgrade`, `Upgrade: websocket`) |
		  | **协议开销** | 相对较低 (文本格式，基于 HTTP 头) | 较低 (有轻量级的帧结构) |
		  | **数据传输格式** | **纯文本** (通常 JSON 或自定义格式) | **文本或二进制数据** |
		  | **二进制支持** | 需要 Base64 编码 | **原生支持** |
		  | **自动重连** | **内置** | 需要客户端手动实现 |
		  | **事件 ID/断点续传** | **内置** (`id:`, `Last-Event-ID`) | 需要应用层协议实现 |
		  | **协议复杂度** | **简单** (文本流，标准 HTTP) | **中等** (帧结构、掩码、心跳等) |
		  | **浏览器 API** | `EventSource` (简单易用) | `WebSocket` (需要手动管理连接、消息、错误) |
		  | **浏览器兼容性** | 所有现代浏览器 (不支持 IE/老 Edge) | **广泛支持** (包括现代浏览器和较老浏览器) |
		  | **防火墙/代理友好度** | **高** (看起来像普通 HTTP 流) | **中等/低** (可能被某些严格策略阻止) |
		  | **HTTP 特性集成** | **天然支持** (Cookies, Auth, CORS) | 需要握手时传递信息，之后独立于 HTTP |
		  | **适用场景** | 服务器向客户端推送实时更新、通知、流数据 | 需要双向实时交互的应用 (聊天、协作、游戏、实时控制) |
	- ### 简单总结区别
	  background-color:: green
		- **SSE：** 基于 HTTP 的**单向**服务器推送。**简单、易用、自动重连、内置事件 ID**，适合服务器主导的实时更新流。**文本数据**。
		- **WebSocket：** 独立的**双向**全双工通信协议。**功能更强大、支持二进制、延迟可能更低**，适合需要客户端和服务器频繁、低延迟交互的场景。**复杂度更高**。
	- ### 具体应用场景
		- #### SSE 的理想应用场景 (主要是服务器推送信息)
			- **实时信息流：**
				- **股票行情更新：** 持续推送股票价格变动。
				  **新闻推送：** 实时推送突发新闻或头条更新。
				  **社交媒体动态：** 推送新的关注者、点赞、评论通知。
				  **体育赛事比分更新：** 实时推送比赛得分和关键事件。
			- **监控仪表盘：**
				- **服务器监控：** 实时显示 CPU、内存、网络使用率等指标。
				  **应用性能监控 (APM)：** 推送实时性能指标和告警。
				  **物联网 (IoT) 设备状态：** 显示传感器读数（温度、湿度、位置等）的实时变化。
			- **通知系统：**
				- **新邮件/消息通知：** 在用户界面实时提示有新邮件或聊天消息到达。
				  **后台任务进度/状态：** 显示长时间运行任务（如文件上传、数据处理）的实时进度百分比或完成状态。
				  **系统告警：** 实时推送关键系统告警信息。
			- **实时日志流：**
				- 将服务器或应用程序的日志实时推送到管理控制台供查看。
			- **简单实时数据展示：**
				- 实时显示投票结果、在线用户数、倒计时等。
		- #### WebSocket 的理想应用场景 (需要双向、交互式通信)
			- **聊天应用：** 用户之间或群组内的实时消息发送和接收。
			- **在线协作工具：**
				- **文档协作：** 多人同时编辑文档时的实时光标位置、内容更改同步。
				- **白板应用：** 实时同步绘图操作。
			- **多人在线游戏：** 玩家位置、动作、状态、游戏事件的实时同步。
			- **实时金融交易平台：** 不仅接收报价，还需要快速发送交易指令。
			- **实时控制面板：** 例如，控制智能家居设备（开灯、调温），需要接收状态反馈并发送控制命令。
			- **需要极低双向延迟的应用：** 如在线竞拍、实时语音/视频通信（虽然通常用 WebRTC，但信令可用 WebSocket）。
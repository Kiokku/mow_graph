- > https://www.hello-algo.com/chapter_backtracking/subset_sum_problem/
-
- > ❓ **Question**
  >
  > 给定一个正整数数组 `nums` 和一个目标正整数 `target` ，请找出所有可能的组合，使得组合中的元素和等于 `target` 。给定数组无重复元素，每个元素可以被选取多次。请以列表形式返回这些组合，列表中不应包含重复组合。
- ## 从全排列引出解法
	- 本题允许重复选取同一元素，因此无需借助 `selected` 布尔列表来记录元素是否已被选择。我们可以对全排列代码进行小幅修改，初步得到解题代码。
	- ```
	  /* 回溯算法：子集和 I */
	  function backtrack(state, target, total, choices, res = []) {
	      // 子集和等于 target 时，记录解
	      if (total === target) {
	          res.push(state);
	          return;
	      }
	      // 遍历所有选择
	      for (let i = 0; i < choices.length; i++) {
	          // 剪枝：若子集和超过 target ，则跳过该选择
	          if (total + choices[i] > target) {
	              continue;
	          }
	          // 尝试：做出选择，更新元素和 total
	          state.push(choices[i]);
	          // 进行下一轮选择
	          backtrack(state, target, total + choices[i], choices, res);
	          // 回退：撤销选择，恢复到之前的状态
	          state.remove(state.size() - 1);
	      }
	  }
	  
	  /* 求解子集和 I（包含重复子集） */
	  function subsetSumINaive(nums, target) {
	      const state = []; // 状态（子集）
	      let total = 0; // 子集和
	      const res = []; // 结果列表（子集列表）
	      backtrack(state, target, total, nums, res);
	      return res;
	  }
	  ```
	- ![image.png](../assets/image_1688724029170_0.png)
	- **虽然成功找出了所有和为 9 的子集，但其中存在重复的子集 [4,5] 和 [5,4]**
- ## 重复子集剪枝
	-
- > https://www.hello-algo.com/chapter_hashing/hash_map/
-
- ## 哈希表
	- 哈希表通过建立「键 key」与「值 value」之间的映射，实现高效的元素查询。具体而言，我们向哈希表输入一个 key，则可以在 $O(1)$ 时间内获取对应的 value 。
	- 在哈希表中增删查改的时间复杂度都是 $O(1)$ ，全面胜出！因此，哈希表常用于[[#blue]]==对查找效率要求较高==的场景。
	- [[#blue]]==哈希表常用操作==
	  collapsed:: true
		- 哈希表的基本操作包括 **初始化、查询操作、添加与删除键值对**。
			- ```
			  /* 初始化哈希表 */
			  const map = new ArrayHashMap();
			  /* 添加操作 */
			  // 在哈希表中添加键值对 (key, value)
			  map.set(12836, '小哈');
			  map.set(15937, '小啰');
			  map.set(16750, '小算');
			  map.set(13276, '小法');
			  map.set(10583, '小鸭');
			  
			  /* 查询操作 */
			  // 向哈希表输入键 key ，得到值 value
			  let name = map.get(15937);
			  
			  /* 删除操作 */
			  // 在哈希表中删除键值对 (key, value)
			  map.delete(10583);
			  ```
		- 遍历哈希表有三种方式，即 **遍历键值对、遍历键、遍历值**。
			- ```
			  /* 遍历哈希表 */
			  console.info('\n遍历键值对 Key->Value');
			  for (const [k, v] of map.entries()) {
			      console.info(k + ' -> ' + v);
			  }
			  console.info('\n单独遍历键 Key');
			  for (const k of map.keys()) {
			      console.info(k);
			  }
			  console.info('\n单独遍历值 Value');
			  for (const v of map.values()) {
			      console.info(v);
			  }
			  ```
	- [[#blue]]==哈希函数==
		- 哈希表的底层实现为**数组**，同时可能包含链表、二叉树（红黑树）等数据结构，以提高查询性能（将在下节讨论）。
		- 首先考虑最简单的情况，**仅使用一个数组来实现哈希表**。通常，我们将数组中的每个空位称为「桶 Bucket」，用于存储键值对。
		- 我们将键值对 key, value 封装成一个类 `Entry` ，并将所有 `Entry` 放入数组中。这样，数组中的每个 `Entry` 都具有唯一的索引。为了建立 key 和索引之间的映射关系，我们需要使用「哈希函数 Hash Function」。
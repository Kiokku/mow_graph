- > [Hello 算法 ](https://www.hello-algo.com/)
- > [算法项目手册](https://labuladong.github.io/zgnb/)
-
- ## 时间复杂度$O(n)$
	- [[#blue]]==时间复杂度分析==，其统计的不是算法运行时间，**而是算法运行时间随着数据量变大时的增长趋势**。
	- [[#blue]]==函数渐近上界==，大 $O$ 记号Big-$O$ Notation」，表示函数 $T(n)$的「渐近上界 Asymptotic Upper Bound」。
		- ![image.png](../assets/image_1683716969907_0.png)
		- 从本质上讲，计算渐近上界就是寻找一个函数 $f(n)$ ，使得当 $n$ 趋向于无穷大时，$T(n)$ 和 $f(n)$ 处于相同的增长级别，仅相差一个常数项 $c$ 的倍数。
	- 推算方法：[[#blue]]==首先统计操作数量，然后判断渐近上界。==
	  collapsed:: true
		- 统计操作数量
			- 1.  **忽略与 $n$ 无关的操作**。
			  2. **省略所有系数**。例如，循环 2$n$ 次、5$n$+1 次等，都可以简化记为 $n$ 次，因为 $n$ 前面的系数对时间复杂度没有影响。
			  3. **循环嵌套时使用乘法**。总操作数量等于外层循环和内层循环操作数量之积，每一层循环依然可以分别套用上述 `1.` 和 `2.` 技巧。
		- 判断渐近上界
			- **时间复杂度由多项式** $T(n)$ **中最高阶的项来决定。**
			- ![image.png](../assets/image_1683719254452_0.png)
			-
		- ```
		  function algorithm(n) {
		      let a = 1;  // +0（技巧 1）
		      a = a + n;  // +0（技巧 1）
		      // +n（技巧 2）
		      for (let i = 0; i < 5 * n + 1; i++) {
		          console.log(0);
		      }
		      // +n*n（技巧 3）
		      for (let i = 0; i < 2 * n; i++) {
		          for (let j = 0; j < n + 1; j++) {
		              console.log(0);
		          }
		      }
		  }
		  
		  ```
		- 以下示例展示了使用上述技巧前、后的统计结果。
			- > $T(n)=2n(n+1)+(5n+1)+2$                   完整统计
			- > $T(n)=n^2+n$                                                       简化技巧
			- 最终，两者都能推出相同的时间复杂度结果，即 $O(n^2)$。
	- 常见类型
		- $$O(1)<O(\log{n})<O(n)<O(n \log{n})<O(n^2)<O(2^n)<O(n!)$$
		- ![image.png](../assets/image_1683726104123_0.png)
		- 常数阶$O(1)$
			- 常数阶的操作数量与输入数据大小 $n$ 无关，即不随着 $n$ 的变化而变化。
			- ```
			  /* 常数阶 */
			  function constant(n) {
			      let count = 0;
			      const size = 100000;
			      for (let i = 0; i < size; i++) count++;
			      return count;
			  }
			  ```
		- 线性阶$O(n)$
			- 线性阶的操作数量相对于输入数据大小以线性级别增长。线性阶通常出现在单层循环中。
			- ```
			  /* 线性阶 */
			  function linear(n) {
			      let count = 0;
			      for (let i = 0; i < n; i++) count++;
			      return count;
			  }
			  ```
		- 平方阶$O(n^2)$
			- ```
			  /* 平方阶 */
			  function quadratic(n) {
			      let count = 0;
			      // 循环次数与数组长度成平方关系
			      for (let i = 0; i < n; i++) {
			          for (let j = 0; j < n; j++) {
			              count++;
			          }
			      }
			      return count;
			  }
			  ```
		- 指数阶$O(2^n)$
			- 指数阶增长非常迅速，在实际应用中[[#red]]==通常是不可接受==的。若一个问题使用「暴力枚举」求解的时间复杂度为 $O(2^n)$ ，那么通常需要使用「动态规划」或「贪心算法」等方法来解决。
			-
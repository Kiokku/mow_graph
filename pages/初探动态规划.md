- > https://www.hello-algo.com/chapter_dynamic_programming/intro_to_dynamic_programming/
-
- **「动态规划 Dynamic Programming」**是一种通过将复杂问题分解为更简单的子问题的方式来求解问题的方法。它将一个问题分解为一系列更小的子问题，并通过存储子问题的解来避免重复计算，从而大幅提升时间效率。
- > ❓ 爬楼梯
  >
  > 给定一个共有 $n$ 阶的楼梯，你每步可以上 1 阶或者 2 阶，请问有多少种方案可以爬到楼顶。
- ![image.png](../assets/image_1689154160717_0.png)
- 本题的目标是求解方案数量，**我们可以考虑通过回溯来穷举所有可能性**。具体来说，将爬楼梯想象为一个多轮选择的过程：[[#blue]]==从地面出发，每轮选择上 1 阶或 2 阶，每当到达楼梯顶部时就将方案数量加 1 ，当越过楼梯顶部时就将其剪枝。==
-
- ## 方法一：暴力搜索
	- 对于本题，我们可以尝试将问题拆解为更小的子问题。设爬到第 $i$ 阶共有 $dp[i]$ 种方案，那么 $dp[i]$ 就是原问题，其子问题包括:
	- $$dp[i-1], dp[i-2], dp[i-3], \cdots, dp[2], dp[1]$$
	- 由于每轮只能上 1 阶或 2 阶，因此当我们站在第 $i$ 阶楼梯上时，上一轮只可能站在第 $i−1$ 阶或第 $i−2$ 阶上。因此，**爬到第 $i−1$ 阶的方案数加上爬到第 $i−2$ 阶的方案数就等于爬到第 $i$ 阶的方案数**，即：
	- $$dp[i] = dp[i-1]+dp[i-2]$$
	- 也就是说，在爬楼梯问题中，**各个子问题之间不是相互独立的，原问题的解可以由子问题的解构成**。
	- 我们可以基于此递推公式写出暴力搜索代码：以 $dp[n]$ 为起始点，**从顶至底地将一个较大问题拆解为两个较小问题的和**，直至到达最小子问题 ��[1] 和 ��[2] 时返回。其中，最小子问题的解 ��[1]=1 , ��[2]=2 是已知的，代表爬到第 1 , 2 阶分别有 1 , 2 种方案。
- ## 自我介绍
- ## 项目面试
	- ### Redux
	  background-color:: green
		- ((6499b665-777d-4d8a-8dab-9ef1b34c0a36))
		- ((64b4dcbf-f5f5-4575-a537-c6bc27b18dfc))
		- ((64c87633-9bcc-48f2-813b-d6ede014c425))
		- 项目中的实际应用：
			- 健康画像是用户的健康数据集合DTO，包括基本信息、医疗信息（自主输入的）、系统推送的潜在健康风险。
	- ### html2canvas
	  background-color:: green
		- #### 项目中的应用
			- 用户查看健康报告、运动打卡等场景，截图生成海报分享
		- #### html2canvas 截图原理
			- 将DOM对象进行迭代克隆和解析，按照层叠关系自顶向下逐步绘制到 canvas 对象里，然后利用 canvas 的底层 API `toDataURL`和 `toBlob`转换成图片数据。
			- ![image.png](../assets/image_1695219776634_0.png)
		- #### [[#blue]]==html2canvas 在 React 中的使用==
			- 1. 获取节点：`let img = document.querySelector("#myImg");`
			- 2. 配置需要参数：
				- ```
				  let options = {
				          useCORS: true,// 开启跨域
				          backgroundColor: "#caddff",// 背景色
				          ignoreElements: (ele) => {},// dom节点
				          scale: 4,// 渲染出来的比例
				  };
				  ```
			- 3. 调用方法，在回调中即可获取到对应的`canvas`对象，通过`canvas.toDataURL`可以将`canvas`对象转换为`base64`的图片地址，再创建一个`a`标签模拟点击即可触发图片下载到本地：
				- ```
				  html2canvas(img, options).then((canvas) => {
				          let url = canvas.toDataURL("image/png"); // canvas转png（base64）
				  		const link = document.createElement('a');
				  		link.href = dataURL;
				  		link.download = 'poster.png';
				  		// 模拟点击链接，触发下载
				  		link.click();
				        });
				  ```
		- #### [[#green]]==html2canvas基本参数说明==
			- |属性名|默认值|描述|
			  |--|--|--|
			  |allowTaint|false|是否允许跨域图像。会污染画布，导致无法使用canvas.toDataURL 方法|
			  |backgroundColor|#ffffff	|画布背景色（如果未在DOM中指定），设置null为透明|
			  |canvas|null|现有canvas元素用作绘图的基础|
			  |foreignObjectRendering|false|如果浏览器支持，是否使用ForeignObject渲染|
			  |scale|window.devicePixelRatio|用于渲染的比例。默认为浏览器设备像素比率|
			  |useCORS|false|是否尝试使用CORS从服务器加载图像|
		- #### 使用时遇见的坑点及解决方案
		  background-color:: pink
			- #### **图片跨域问题**
				- html2canvas的配置项中配置 `allowTaint:true` 或 `useCORS:true`(二者不可共同使用)
				  logseq.order-list-type:: number
				- img 标签增加 `crossOrigin='anonymous'`图片服务器配置 Access-Control-Allow-Origin 或使用代理；
				  logseq.order-list-type:: number
				- 服务器需要配置 `Access-Control-Allow-Origin`信息。
				  logseq.order-list-type:: number
			- #### **图片清晰度差**
				- 调整配置项 `scale`；
				  logseq.order-list-type:: number
				- 两次canvas绘制方案：
				  logseq.order-list-type:: number
				  collapsed:: true
					- 使用html2canvas进行预渲染：在JavaScript代码中，使用html2canvas库的`html2canvas()`函数对要截图的元素进行预渲染。将要截图的元素作为参数传递给该函数。
					  logseq.order-list-type:: number
						- ```
						  var elementToCapture = document.getElementById('elementId');
						  
						  html2canvas(elementToCapture, {
						    canvas: document.getElementById('preCanvas')
						  }).then(function(preCanvas) {
						    // 预渲染完成后执行下一步操作
						  });
						  ```
					- 调整预渲染canvas的大小：由于预渲染canvas的大小可能与所需的截图大小不匹配，需要调整预渲染canvas的大小以适应所需区域的尺寸，并结合设备像素比进行缩放。
					  logseq.order-list-type:: number
						- ```
						  var desiredWidth = 800;
						  var desiredHeight = 600;
						  var devicePixelRatio = window.devicePixelRatio || 1;
						  
						  var preCtx = document.getElementById('preCanvas').getContext('2d');
						  preCtx.canvas.width = desiredWidth * devicePixelRatio;
						  preCtx.canvas.height = desiredHeight * devicePixelRatio;
						  preCtx.scale(devicePixelRatio, devicePixelRatio);
						  ```
					- 在最终canvas上进行绘制：使用`drawImage()`方法将预渲染canvas上的内容绘制到最终canvas上，并结合设备像素比进行缩小绘制。
					  logseq.order-list-type:: number
						- ```
						  var finalCtx = document.getElementById('finalCanvas').getContext('2d');
						  finalCtx.canvas.width = desiredWidth;
						  finalCtx.canvas.height = desiredHeight;
						  
						  finalCtx.drawImage(preCanvas, 0, 0, desiredWidth, desiredHeight);
						  ```
					- 获取最终截图：使用最终canvas上的`toDataURL()`方法获取最终截图的数据URL，可以将其保存为图像或进行其他操作。
					  logseq.order-list-type:: number
						- ```
						  var finalDataURL = document.getElementById('finalCanvas').toDataURL();
						  console.log('Final screenshot:', finalDataURL);
						  ```
			- #### **滚动元素截图不全**
				- 设置滚动元素提前滚动到顶部。
				- `document.body.scrollTop = document.documentElement.scrollTop = 0;`
		- #### 总结
		  background-color:: pink
			- 基于前端 JS 生成方案具有很多限制：
				- 1. 客户端经常会有些小的兼容性问题，特别是IOS端；
				  2. 在终端差异较大时无法保证不同终端生成的图片完全一样；
				  3. 性能开销比较大，无法预先生成。
			- [[#green]]==考虑替代方案：==
				- 1. 在APP端借助于原生的截图能力；在浏览器里借助人机交互接口进行截图，进而获得真正的用户所见即所得的截图效果。
				- 2. 后台生成是指在 Nodejs 服务端中，通过调用 chrome 内核来加载对应的页面，然后使用浏览器等内置API进行截图，例如使用 puppeteer 生成 pdf。
	- ### QRCode.js
	  background-color:: green
		- ```
		  var qrcode = new QRCode('qrcode', {
		      text: 'your content',
		      width: 256,
		      height: 256,
		      colorDark: '#000000',
		      colorLight: '#ffffff',
		      correctLevel: QRCode.CorrectLevel.H
		  });
		  ```
	- ### Antd From 和配置化 JSON ⽣成表单
	  background-color:: blue
		- ####
- ## 职业规划
- > https://www.hello-algo.com/chapter_stack_and_queue/stack/
-
- ## 栈
	- `栈 Stack`是一种遵循[[#blue]]==先入后出（First In, Last Out）==原则的线性数据结构。
	- 在栈中，我们把堆叠元素的顶部称为**「栈顶」**，底部称为**「栈底」**。将把元素添加到栈顶的操作叫做**「入栈」**，而删除栈顶元素的操作叫做**「出栈」**。
	- ![image.png](../assets/image_1684403663613_0.png){:height 431, :width 726}
	- [[#blue]]==栈常用操作==
		- |方法|描述|时间复杂度|
		  |--|--|--|
		  |push()|元素入栈（添加至栈顶）|$O(1)$|
		  |pop()|栈顶元素出栈|$O(1)$|
		  |peek()|访问栈顶元素|$O(1)$|
		- 通常情况下，我们可以直接使用编程语言内置的栈类。然而，某些语言可能没有专门提供栈类，这时我们可以将该语言的「数组」或「链表」视作栈来使用，并通过“脑补”来忽略与栈无关的操作。
		- ```
		  /* 初始化栈 */
		  // Javascript 没有内置的栈类，可以把 Array 当作栈来使用 
		  const stack = [];
		  
		  /* 元素入栈 */
		  stack.push(1);
		  stack.push(3);
		  stack.push(2);
		  stack.push(5);
		  stack.push(4);
		  
		  /* 访问栈顶元素 */
		  const peek = stack[stack.length-1];
		  
		  /* 元素出栈 */
		  const pop = stack.pop();
		  
		  /* 获取栈的长度 */
		  const size = stack.length;
		  
		  /* 判断是否为空 */
		  const is_empty = stack.length === 0;
		  ```
	- [[#blue]]==栈的实现==
		- `基于链表的实现`
		  collapsed:: true
			- 使用链表来实现栈时，我们可以将链表的头节点视为栈顶，尾节点视为栈底。
			- 对于入栈操作，我们只需将元素插入链表头部，这种节点插入方法被称为**头插法**。而对于出栈操作，只需将头节点从链表中删除即可。
			- ![image.png](../assets/image_1684404573798_0.png){:height 328, :width 525}
			- ![image.png](../assets/image_1684404603355_0.png){:height 360, :width 528}
			- ![image.png](../assets/image_1684404627909_0.png){:height 363, :width 542}
			- 以下是基于链表实现栈的示例代码。
			- ```
			  /* 基于链表实现的栈 */
			  class LinkedListStack {
			      #stackPeek; // 将头节点作为栈顶
			      #stkSize = 0; // 栈的长度
			  
			      constructor() {
			          this.#stackPeek = null;
			      }
			  
			      /* 获取栈的长度 */
			      get size() {
			          return this.#stkSize;
			      }
			  
			      /* 判断栈是否为空 */
			      isEmpty() {
			          return this.size == 0;
			      }
			  
			      /* 入栈 */
			      push(num) {
			          const node = new ListNode(num);
			          node.next = this.#stackPeek;
			          this.#stackPeek = node;
			          this.#stkSize++;
			      }
			  
			      /* 出栈 */
			      pop() {
			          const num = this.peek();
			          this.#stackPeek = this.#stackPeek.next;
			          this.#stkSize--;
			          return num;
			      }
			  
			      /* 访问栈顶元素 */
			      peek() {
			          if (!this.#stackPeek) throw new Error('栈为空');
			          return this.#stackPeek.val;
			      }
			  
			      /* 将链表转化为 Array 并返回 */
			      toArray() {
			          let node = this.#stackPeek;
			          const res = new Array(this.size);
			          for (let i = res.length - 1; i >= 0; i--) {
			              res[i] = node.val;
			              node = node.next;
			          }
			          return res;
			      }
			  }
			  
			  ```
		- `基于数组的实现`
		  collapsed:: true
			- 在基于「数组」实现栈时，我们可以将[[#blue]]==数组的尾部作为栈顶==。在这样的设计下，入栈与出栈操作就分别对应在数组尾部添加元素与删除元素，时间复杂度都为 $O(1)$ 。
			- ![image.png](../assets/image_1684405388051_0.png){:height 376, :width 662}
			- ![image.png](../assets/image_1684405411491_0.png){:height 383, :width 661}
			- ![image.png](../assets/image_1684405433608_0.png){:height 377, :width 658}
			- 由于入栈的元素可能会源源不断地增加，因此我们可以使用动态数组，这样就无需自行处理数组扩容问题。以下为示例代码。
			- ```
			  /* 基于数组实现的栈 */
			  class ArrayStack {
			      #stack;
			      constructor() {
			          this.#stack = [];
			      }
			  
			      /* 获取栈的长度 */
			      get size() {
			          return this.#stack.length;
			      }
			  
			      /* 判断栈是否为空 */
			      empty() {
			          return this.#stack.length === 0;
			      }
			  
			      /* 入栈 */
			      push(num) {
			          this.#stack.push(num);
			      }
			  
			      /* 出栈 */
			      pop() {
			          if (this.empty()) throw new Error('栈为空');
			          return this.#stack.pop();
			      }
			  
			      /* 访问栈顶元素 */
			      top() {
			          if (this.empty()) throw new Error('栈为空');
			          return this.#stack[this.#stack.length - 1];
			      }
			  
			      /* 返回 Array */
			      toArray() {
			          return this.#stack;
			      }
			  }
			  ```
			-
	- [[#blue]]==两种实现对比==
		- `支持操作`
			- 两种实现都支持栈定义中的各项操作。数组实现额外支持随机访问，但这已超出了栈的定义范畴，因此一般不会用到。
		- `时间效率`
			- 当入栈与出栈操作的元素是基本数据类型（如 `int` , `double` ）时，我们可以得出以下结论：
				- id:: 6465fe8a-815b-4fca-a843-5bc3ca4a1d08
				  1. 基于数组实现的栈在触发扩容时效率会降低，但由于扩容是低频操作，因此平均效率更高；
				  2. 基于链表实现的栈可以提供更加稳定的效率表现；
		- `空间效率`
			- **基于数组实现的栈可能造成一定的空间浪费**。
			- 然而，由于链表节点需要额外存储指针，**因此链表节点占用的空间相对较大**。
			- 综上，我们不能简单地确定哪种实现更加节省内存，需要针对具体情况进行分析。
	- [[#blue]]==栈典型应用==
		- **浏览器中的后退与前进、软件中的撤销与反撤销**。每当我们打开新的网页，浏览器就会将上一个网页执行入栈，这样我们就可以通过「后退」操作回到上一页面。后退操作实际上是在执行出栈。如果要同时支持后退和前进，那么需要两个栈来配合实现。
		- **程序内存管理**。每次调用函数时，系统都会在栈顶添加一个栈帧，用于记录函数的上下文信息。在递归函数中，向下递推阶段会不断执行入栈操作，而向上回溯阶段则会执行出栈操作。
- ## 队列
	- `队列 Queue`是一种遵循[[#blue]]==先入先出（First In, First Out）==规则的线性数据结构。顾名思义，队列模拟了排队现象，即新来的人不断加入队列的尾部，而位于队列头部的人逐个离开。
	- 我们把队列的头部称为「队首」，尾部称为「队尾」，把将元素加入队尾的操作称为「入队」，删除队首元素的操作称为「出队」。
	- ![image.png](../assets/image_1684406115398_0.png){:height 435, :width 742}
	- [[#blue]]==队列常用操作==
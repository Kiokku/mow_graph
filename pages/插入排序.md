- > https://www.hello-algo.com/chapter_sorting/insertion_sort/
-
- **「插入排序 Insertion Sort」**是一种简单的排序算法，它的工作原理与手动整理一副牌的过程非常相似。
- 具体来说，我们在未排序区间选择一个基准元素，将该元素与其左侧已排序区间的元素逐一比较大小，并将该元素插入到正确的位置。
- ## 算法流程
	- 插入排序的整体流程如下：
		- 1. 初始状态下，数组的第 1 个元素已完成排序。
		  2. 选取数组的第 2 个元素作为 `base` ，将其插入到正确位置后，**数组的前 2 个元素已排序**。
		  3. 选取第 3 个元素作为 `base` ，将其插入到正确位置后，**数组的前 3 个元素已排序**。
		  4. 以此类推，在最后一轮中，选取最后一个元素作为 `base` ，将其插入到正确位置后，**所有元素均已排序**。
	- ```
	  /* 插入排序 */
	  function insertionSort(nums) {
	      // 外循环：已排序元素数量为 1, 2, ..., n
	      for (let i = 1; i < nums.length; i++) {
	          let base = nums[i],
	              j = i - 1;
	          // 内循环：将 base 插入到已排序部分的正确位置
	          while (j >= 0 && nums[j] > base) {
	              nums[j + 1] = nums[j]; // 将 nums[j] 向右移动一位
	              j--;
	          }
	          nums[j + 1] = base; // 将 base 赋值到正确位置
	      }
	  }
	  ```
- ## 算法特性
	- **时间复杂度** $O(n^2)$ **、自适应排序**：在遇到有序数据时，插入操作会提前终止。当输入数组完全有序时，插入排序达到最佳时间复杂度 $O(n)$ 。
	- **空间复杂度** $O(1)$ **、原地排序** ：指针 $i , j$ 使用常数大小的额外空间。
	- **稳定排序**：在插入操作过程中，我们会将元素插入到相等元素的右侧，不会改变它们的顺序。
- ## 插入排序优势
	- 尽管插入排序的时间复杂度相比快速排序更高，**但在[[#green]]==数据量较小==的情况下，插入排序通常更快**。
	- 实际上，许多编程语言（例如 Java）的内置排序函数都采用了插入排序，大致思路为：对于长数组，采用基于分治的排序算法，例如快速排序；对于短数组，直接使用插入排序。
	- 在实际情况中，**插入排序的使用频率显著高于冒泡排序和选择排序**。这是因为：
		- 冒泡排序基于元素交换实现，需要借助一个临时变量，共涉及 3 个单元操作；插入排序基于元素赋值实现，仅需 1 个单元操作。因此，**冒泡排序的计算开销通常比插入排序更高**。
		- 选择排序在任何情况下的时间复杂度都为 $O(n^2)$ 。**如果给定一组部分有序的数据，插入排序通常比选择排序效率更高**。
		- 选择排序不稳定，无法应用于多级排序。
- > https://www.hello-algo.com/chapter_sorting/merge_sort/
-
- **「归并排序 Merge Sort」**基于分治思想实现排序，包含**“划分”**和**“合并”**两个阶段：
	- **划分阶段**：通过递归不断地将数组从中点处分开，将长数组的排序问题转换为短数组的排序问题；
	- **合并阶段**：当子数组长度为 1 时终止划分，开始合并，持续地将左右两个较短的有序数组合并为一个较长的有序数组，直至结束；
	- ![image.png](../assets/image_1687869604638_0.png)
- ## 算法流程
	- **“划分阶段”**从顶至底递归地将数组从中点切为两个子数组，直至长度为 1 ：
		- 1. 计算数组中点 `mid` ，递归划分左子数组（区间 `[left, mid]` ）和右子数组（区间 `[mid + 1, right]` ）；
		- 2. 递归执行步骤 `1.` ，直至子数组区间长度为 1 时，终止递归划分；
	- **“合并阶段”**从底至顶地将左子数组和右子数组合并为一个有序数组。需要注意的是，从长度为 1 的子数组开始合并，合并阶段中的每个子数组都是有序的。
	- 观察发现，归并排序的递归顺序与二叉树的后序遍历相同，具体来看：
		- **后序遍历**：先递归左子树，再递归右子树，最后处理根节点。
		- **归并排序**：先递归左子数组，再递归右子数组，最后处理合并。
	- ```
	  /* 合并左子数组和右子数组 */
	  // 左子数组区间 [left, mid]
	  // 右子数组区间 [mid + 1, right]
	  function merge(nums, left, mid, right) {
	      // 初始化辅助数组
	      let tmp = nums.slice(left, right + 1);
	      // 左子数组的起始索引和结束索引
	      let leftStart = left - left,
	          leftEnd = mid - left;
	      // 右子数组的起始索引和结束索引
	      let rightStart = mid + 1 - left,
	          rightEnd = right - left;
	      // i, j 分别指向左子数组、右子数组的首元素
	      let i = leftStart,
	          j = rightStart;
	      // 通过覆盖原数组 nums 来合并左子数组和右子数组
	      for (let k = left; k <= right; k++) {
	          if (i > leftEnd) {
	              // 若“左子数组已全部合并完”，则选取右子数组元素，并且 j++
	              nums[k] = tmp[j++];
	          } else if (j > rightEnd || tmp[i] <= tmp[j]) {
	              // 否则，若“右子数组已全部合并完”或“左子数组元素 <= 右子数组元素”，则选取左子数组元素，并且 i++
	              nums[k] = tmp[i++];
	          } else {
	              // 否则，若“左右子数组都未全部合并完”且“左子数组元素 > 右子数组元素”，则选取右子数组元素，并且 j++
	              nums[k] = tmp[j++];
	          }
	      }
	  }
	  
	  /* 归并排序 */
	  function mergeSort(nums, left, right) {
	      // 终止条件
	      if (left >= right) return; // 当子数组长度为 1 时终止递归
	      // 划分阶段
	      let mid = Math.floor((left + right) / 2); // 计算中点
	      mergeSort(nums, left, mid); // 递归左子数组
	      mergeSort(nums, mid + 1, right); // 递归右子数组
	      // 合并阶段
	      merge(nums, left, mid, right);
	  }
	  ```
	-
	-
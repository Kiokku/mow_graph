- > https://www.hello-algo.com/chapter_dynamic_programming/knapsack_problem/
-
- 背包问题是一个非常好的动态规划入门题目，是动态规划中最常见的问题形式。其具有很多变种，例如 0-1 背包问题、完全背包问题、多重背包问题等。
- > ❓ **Question**
  >
  >给定 $n$ 个物品，第 $i$ 个物品的重量为 $wgt[i-1]$ 、价值为 $val[i-1]$ ，现在有个容量为 $cap$ 的背包，每个物品只能选择一次，问在不超过背包容量下背包中物品的最大价值。
- 我们可以将 0-1 背包问题看作是一个由 $n$ 轮决策组成的过程，每个物体都有不放入和放入两种决策，因此该问题是满足决策树模型的。此外，该问题的目标是求解“在限定背包容量下的最大价值”，因此较大概率是个动态规划问题。我们接下来尝试求解它。
	- ### 第一步：思考每轮的决策，定义状态，从而得到 $dp$ 表
	  background-color:: pink
		- 在 0-1 背包问题中，不放入背包，背包容量不变；放入背包，背包容量减小。由此可得状态定义：当前物品编号 $i$ 和剩余背包容量 $c$ ，记为 $[i,c]$ 。
		- 状态 \([i, c]\) 对应的子问题为：**前 \(i\) 个物品在剩余容量为 \(c\) 的背包中的最大价值**，记为 \(dp[i, c]\) 。
		- 需要求解的是 \(dp[n, cap]\) ，因此需要一个尺寸为 \((n+1) \times (cap+1)\) 的二维 \(dp\) 表。
	- ### 第二步：找出最优子结构，进而推导出状态转移方程
	  background-color:: pink
		- 当我们做出物品 \(i\) 的决策后，剩余的是前 \(i-1\) 个物品的决策。因此，状态转移分为两种情况：
			- **不放入物品 \(i\)** ：背包容量不变，状态转移至 \([i-1, c]\) ；
			- **放入物品 \(i\)** ：背包容量减小 \(wgt[i-1]\) ，价值增加 \(val[i-1]\) ，状态转移至 \([i-1, c-wgt[i-1]]\) ；
		- 上述的状态转移向我们揭示了本题的最优子结构：**最大价值 \(dp[i, c]\) 等于不放入物品 \(i\) 和放入物品 \(i\) 两种方案中的价值更大的那一个**。由此可推出状态转移方程：
		- $$dp[i, c] = \max(dp[i-1, c], dp[i-1, c - wgt[i-1]] + val[i-1])$$
		- 需要注意的是，若当前物品重量 \(wgt[i - 1]\) 超出剩余背包容量 \(c\) ，则只能选择不放入背包。
	- ### 第三步：确定边界条件和状态转移顺序
	  background-color:: pink
		- 当无物品或无剩余背包容量时最大价值为 \(0\) ，即所有 \(dp[i, 0]\) 和 \(dp[0, c]\) 都等于 \(0\) 。
		- 当前状态 \([i, c]\) 从上方的状态 \([i-1, c]\) 和左上方的状态 \([i-1, c-wgt[i-1]]\) 转移而来，因此通过两层循环正序遍历整个 \(dp\) 表即可。
- ## 方法一：暴力搜索
	- 搜索代码包含以下要素：
		- **递归参数**：状态 $[i,c]$ ；**返回值**：子问题的解 $dp[i,c]$ 。
		  **终止条件**：当物品编号越界 $i=0$ 或背包剩余容量为 0 时，终止递归并返回价值 0 。
		  **剪枝**：若当前物品重量超出背包剩余容量，则只能不放入背包。
	- ```
	  /* 0-1 背包：暴力搜索 */
	  function knapsackDFS(wgt = [], val = [], i, c) {
	      // 若已选完所有物品或背包无容量，则返回价值 0
	      if (i == 0 || c == 0) {
	          return 0;
	      }
	      // 若超过背包容量，则只能不放入背包
	      if (wgt[i - 1] > c) {
	          return knapsackDFS(wgt, val, i - 1, c);
	      }
	      // 计算不放入和放入物品 i 的最大价值
	      const no = knapsackDFS(wgt, val, i - 1, c);
	      const yes = knapsackDFS(wgt, val, i - 1, c - wgt[i - 1]) + val[i - 1];
	      // 返回两种方案中价值更大的那一个
	      return Math.max(no, yes);
	  }
	  ```
- ## 方法二：记忆化搜索
  id:: 64b55880-f874-4592-8171-538557085edc
	- 为了防止重复求解重叠子问题，我们借助一个记忆列表 `mem` 来记录子问题的解，其中 `mem[i][c]` 对应解$dp[i,c]$。
	- ```
	  /* 0-1 背包：记忆化搜索 */
	  function knapsackDFSMem(wgt = [], val = [], mem, i, c) {
	      // 若已选完所有物品或背包无容量，则返回价值 0
	      if (i == 0 || c == 0) {
	          return 0;
	      }
	      // 若已有记录，则直接返回
	      if (mem[i][c] != -1) {
	          return mem[i][c];
	      }
	      // 若超过背包容量，则只能不放入背包
	      if (wgt[i - 1] > c) {
	          return knapsackDFSMem(wgt, val, mem, i - 1, c);
	      }
	      // 计算不放入和放入物品 i 的最大价值
	      const no = knapsackDFSMem(wgt, val, mem, i - 1, c);
	      const yes = knapsackDFSMem(wgt, val, mem, i - 1, c - wgt[i - 1]) + val[i - 1];
	      // 记录并返回两种方案中价值更大的那一个
	      mem[i][c] = Math.max(no, yes);
	      return mem[i][c];
	  }
	  
	  ```
- ## 方法三：动态规划
	- ```
	  /* 0-1 背包：动态规划 */
	  function knapsackDP(wgt = [], val = [], cap) {
	      const n = wgt.length;
	      // 初始化 dp 表
	  	const dp = Array(n + 1).fill(Array(cap + 1));
	      // 状态转移
	      for (int i = 1; i <= n; i++) {
	          for (int c = 1; c <= cap; c++) {
	              if (wgt[i - 1] > c) {
	                  // 若超过背包容量，则不选物品 i
	                  dp[i][c] = dp[i - 1][c];
	              } else {
	                  // 不选和选物品 i 这两种方案的较大值
	                  dp[i][c] = Math.max(dp[i - 1][c], dp[i - 1][c - wgt[i - 1]] + val[i - 1]);
	              }
	          }
	      }
	      return dp[n][cap];
	  }
	  
	  ```
	-
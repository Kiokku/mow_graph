- > https://www.hello-algo.com/chapter_dynamic_programming/knapsack_problem/
-
- 背包问题是一个非常好的动态规划入门题目，是动态规划中最常见的问题形式。其具有很多变种，例如 0-1 背包问题、完全背包问题、多重背包问题等。
- > ❓ **Question**
  >
  >给定 $n$ 个物品，第 $i$ 个物品的重量为 $wgt[i-1]$ 、价值为 $val[i-1]$ ，现在有个容量为 $cap$ 的背包，每个物品只能选择一次，问在不超过背包容量下背包中物品的最大价值。
- 我们可以将 0-1 背包问题看作是一个由 $n$ 轮决策组成的过程，每个物体都有不放入和放入两种决策，因此该问题是满足决策树模型的。此外，该问题的目标是求解“在限定背包容量下的最大价值”，因此较大概率是个动态规划问题。我们接下来尝试求解它。
	- ### 第一步：思考每轮的决策，定义状态，从而得到 $dp$ 表
	  background-color:: pink
		- 在 0-1 背包问题中，不放入背包，背包容量不变；放入背包，背包容量减小。由此可得状态定义：当前物品编号 $i$ 和剩余背包容量 $c$ ，记为 $[i,c]$ 。
		- 状态 \([i, c]\) 对应的子问题为：**前 \(i\) 个物品在剩余容量为 \(c\) 的背包中的最大价值**，记为 \(dp[i, c]\) 。
		- 需要求解的是 \(dp[n, cap]\) ，因此需要一个尺寸为 \((n+1) \times (cap+1)\) 的二维 \(dp\) 表。
	- ### 第二步：找出最优子结构，进而推导出状态转移方程
	  background-color:: pink
		- 当我们做出物品 \(i\) 的决策后，剩余的是前 \(i-1\) 个物品的决策。因此，状态转移分为两种情况：
			- **不放入物品 \(i\)** ：背包容量不变，状态转移至 \([i-1, c]\) ；
			- **放入物品 \(i\)** ：背包容量减小 \(wgt[i-1]\) ，价值增加 \(val[i-1]\) ，状态转移至 \([i-1, c-wgt[i-1]]\) ；
		- 上述的状态转移向我们揭示了本题的最优子结构：**最大价值 \(dp[i, c]\) 等于不放入物品 \(i\) 和放入物品 \(i\) 两种方案中的价值更大的那一个**。由此可推出状态转移方程：
		- $$dp[i, c] = \max(dp[i-1, c], dp[i-1, c - wgt[i-1]] + val[i-1])$$
		- 需要注意的是，若当前物品重量 \(wgt[i - 1]\) 超出剩余背包容量 \(c\) ，则只能选择不放入背包。
	- ### 第三步：确定边界条件和状态转移顺序
	  background-color:: pink
		- 当无物品或无剩余背包容量时最大价值为 \(0\) ，即所有 \(dp[i, 0]\) 和 \(dp[0, c]\) 都等于 \(0\) 。
		- 当前状态 \([i, c]\) 从上方的状态 \([i-1, c]\) 和左上方的状态 \([i-1, c-wgt[i-1]]\) 转移而来，因此通过两层循环正序遍历整个 \(dp\) 表即可。
- ## 方法一：暴力搜索
	- 搜索代码包含以下要素：
		- **递归参数**：状态 $[i,c]$ ；**返回值**：子问题的解 $dp[i,c]$ 。
		  **终止条件**：当物品编号越界 $i=0$ 或背包剩余容量为 0 时，终止递归并返回价值 0 。
		  **剪枝**：若当前物品重量超出背包剩余容量，则只能不放入背包。
	- ```
	  ```
- > [https://www.hello-algo.com/chapter_array_and_linkedlist/array/](https://www.hello-algo.com/chapter_array_and_linkedlist/array/)
-
- ## 数组
	- 「数组 Array」是一种线性数据结构，其将相同类型元素存储在连续的内存空间中。我们将元素在数组中的位置称为元素的「索引 Index」。
	- ![image.png](../assets/image_1683881183272_0.png){:height 438, :width 742}
	- [[#blue]]==数组优点==
		- **在数组中访问元素非常高效**。
	- [[#red]]==数组缺点==
		- **数组在初始化后长度不可变**。（Python List, Go Slice, JS/TS Array, C++ vector 都采用了动态数组的策略，用户最常用的是动态数组，底层实现了扩容机制。）
		- **数组中插入或删除元素效率低下**。如果我们想要在数组中间插入一个元素，由于数组元素在内存中是“紧挨着的”，它们之间没有空间再放任何数据。因此，我们不得不将此索引之后的所有元素都向后移动一位，然后再把元素赋值给该索引。
	- [[#green]]==数组常用操作==
		- **数组遍历**。以下介绍两种常用的遍历方法。
			- ```
			  /* 遍历数组 */
			  function traverse(nums) {
			      let count = 0;
			      // 通过索引遍历数组
			      for (let i = 0; i < nums.length; i++) {
			          count++;
			      }
			      // 直接遍历数组
			      for (let num of nums) {
			          count += 1;
			      }
			  }
			  ```
		- **数组查找**。通过遍历数组，查找数组内的指定元素，并输出对应索引。
			- ```
			  /* 在数组中查找指定元素 */
			  function find(nums, target) {
			      for (let i = 0; i < nums.length; i++) {
			          if (nums[i] == target) return i;
			      }
			      return -1;
			  }
			  ```
- ## 链表
	- 与数组相比，链表更具灵活性，它可以被存储在非连续的内存空间中。
	- 「链表 Linked List」是一种线性数据结构，其每个元素都是一个节点对象，各个节点之间通过指针连接，从当前节点通过指针可以访问到下一个节点。**由于指针记录了下个节点的内存地址，因此无需保证内存地址的连续性**，从而可以将各个节点分散存储在内存各处。
	- ![image.png](../assets/image_1683888278380_0.png){:height 425, :width 774}
	- ```
	  /* 链表节点类 */
	  class ListNode {
	      val;
	      next;
	      constructor(val, next) {
	          this.val = (val === undefined ? 0 : val);       // 节点值
	          this.next = (next === undefined ? null : next); // 指向下一节点的引用
	      }
	  }
	  ```
	- **链表初始化方法**。建立链表分为两步，第一步是初始化各个节点对象，第二步是构建引用指向关系。完成后，即可以从链表的头节点（即首个节点）出发，通过指针 `next` 依次访问所有节点。
	- ```
	  /* 初始化链表 1 -> 3 -> 2 -> 5 -> 4 */
	  // 初始化各个节点
	  const n0 = new ListNode(1);
	  const n1 = new ListNode(3);
	  const n2 = new ListNode(2);
	  const n3 = new ListNode(5);
	  const n4 = new ListNode(4);
	  // 构建引用指向
	  n0.next = n1;
	  n1.next = n2;
	  n2.next = n3;
	  n3.next = n4;
	  ```
	- [[#blue]]==链表优点==
		- **链表中插入与删除节点的操作效率高**。例如，如果我们想在链表中间的两个节点 `A` , `B` 之间插入一个新节点 `P` ，我们只需要改变两个节点指针即可，时间复杂度为 $O(1)$ ；相比之下，数组的插入操作效率要低得多。
		- ```
		  /* 在链表的节点 n0 之后插入节点 P */
		  function insert(n0, P) {
		      const n1 = n0.next;
		      P.next = n1;
		      n0.next = P;
		  }
		  
		  /* 删除链表的节点 n0 之后的首个节点 */
		  function remove(n0) {
		      if (!n0.next) return;
		      // n0 -> P -> n1
		      const P = n0.next;
		      const n1 = P.next;
		      n0.next = n1;
		  }
		  
		  ```
	- [[#red]]==链表缺点==
		- **链表访问节点效率较低**。
		- **链表的内存占用较大**。链表以节点为单位，每个节点除了保存值之外，还需额外保存指针（引用）。这意味着在相同数据量的情况下，链表比数组需要占用更多的内存空间。
	- [[#green]]==链表常用操作==
		-